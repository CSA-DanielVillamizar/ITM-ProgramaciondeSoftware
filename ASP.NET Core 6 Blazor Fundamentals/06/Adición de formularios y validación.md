# Adición de formularios y validación

Cátedra Programación de Software y Programática - Fundamentos de ASP.NET Core 6 Blazor

Introducción al módulo

Usando nuestra aplicación en su estado actual, ahora podemos acceder a una API para obtener datos reales. Nuestras páginas, nuestras pantallas, digamos en este punto, solo muestran datos, no podemos editar nada todavía, ni podemos, por ejemplo, agregar un empleado. Ese será el tema de este nuevo módulo en el curso Fundamentos de Blazor 6 aquí en Pluralsight. Vamos a trabajar con formularios, y mientras lo hacemos, vamos a forzar, digamos, a guiar a nuestros usuarios para que ingresen datos correctos a través de la validación. Entonces, ¿cómo se organizará este módulo entonces? Bueno, comenzaremos el módulo observando el enlace de datos. Ya he mencionado el término varias veces, pero en el contexto de la edición de datos a través de un formulario, será muy útil. Así que ese será nuestro primer tema. A continuación, veremos el mayor cambio en nuestra aplicación con la creación de un formulario, y ese formulario se utilizará tanto para crear nuevos empleados como para editar los existentes. Usamos un conjunto de componentes de entrada que viene con Blazor para crear el formulario. Finalmente, ampliaremos el modelo y el formulario para que también tengamos soporte para la validación. ¿Suena bien? Sumerjámonos.

Comprender el enlace de datos

Arriba primero, enlace de datos. Blazor incluye compatibilidad con el enlace de datos, lo que nos facilita la exposición, por ejemplo, de una propiedad de cadena y el enlace declarativo a esa propiedad en el código de marcado. Sin saberlo realmente, en el módulo anterior ya utilizó el enlace de datos cuando creó la pantalla de detalle del empleado. Ahora Blazor en realidad tiene diferentes opciones para el enlace de datos. Podemos hacer enlaces de datos unidireccionales, enlaces de datos bidireccionales y enlaces a un parámetro de componente. El enlace de datos unidireccional, como su nombre lo indica, indica que los datos fluyen en una dirección, lo que significa que las actualizaciones del valor ocurrirán de una sola manera. En el fragmento que ve en la diapositiva, mostramos el valor de las propiedades FirstName y LastName. Estamos usando el enlace de datos aquí, y estamos usando para eso el símbolo @. Esto indica que el valor debe recuperarse dinámicamente. Si el valor de FirstName o LastName cambia, por ejemplo, por una interacción del usuario, como hacer clic en el botón, la interfaz de usuario también se actualizará. En Blazor, la ejecución de controladores de eventos, como hacer clic en un botón, volverá a representar automáticamente la interfaz de usuario. Realmente no necesitamos pedir eso específicamente en el código. Usar el enlace de datos tiene sentido cuando queremos que exista este vínculo entre el origen y el destino. Ya ha visto que en el código HTML, también podemos usar la notación de puntos, por ejemplo, para vincular el Employee.FirstName, lo que requiere que el Employee esté disponible para vincular. También es posible usar esta sintaxis para el enlace de datos dentro de un control de formulario, como una entrada. Aquí estamos configurando el valor de la entrada nuevamente en la propiedad FirstName del empleado. Ahora tenga cuidado sin embargo. Aunque esto ahora es una entrada, cambiar el valor en la interfaz de usuario no tendrá ningún efecto en la fuente, por lo que la instancia de empleado. El enlace de datos real donde podemos permitir que el usuario ingrese datos y capturar esos datos ingresados ​​requerirá el uso de la directiva @bind, especificada en el componente de entrada. Especificará a qué nos vinculamos. Puede ser una propiedad, un campo o incluso una expresión de Razor. Lo veremos en acción en solo un minuto. El uso del enlace de datos generalmente ocurrirá en combinación con un formulario. ¿Probablemente esté familiarizado con un formulario HTML? Bueno, por supuesto, Blazor se basa completamente en esto. Usando el formulario, podemos permitir que los usuarios ingresen información como los detalles de un nuevo empleado. La información ingresada por el usuario generalmente se enviará al back-end. Entonces, lo que haremos será usar los métodos definidos en nuestra API para crear o editar un empleado. Dentro del formulario, podemos usar, digamos, los componentes de formulario HTML predeterminados, como input = text. Mientras esto funciona, Blazor viene con un conjunto de componentes de entrada que son más óptimos para trabajar. Admiten funciones de validación listas para usar, y también las veremos más adelante en este módulo. Cuando creemos nuestro formulario en el siguiente tema, usaré estos componentes Blazor, pero por ahora, usemos primero los HTML. Aquí podemos ver el enlace de datos en un control de formulario HTML normal en funcionamiento. Utilicé una entrada HTML normal, pero luego noté que usé @bind, y su valor se establece en la propiedad a la que me estoy vinculando, la propiedad lastName del empleado, que probablemente sea, nuevamente, una propiedad definida en la clase de componente. Al escribir este @bind aquí, Estoy vinculando en un modo bidireccional este componente con el valor. Entonces, si se establece un valor en la inicialización del componente, veremos este valor. Pero si el usuario ahora hace un cambio, el valor también se actualizará. El comportamiento predeterminado será que el valor se actualizará cuando el usuario toque la entrada. En estos últimos, también podemos influir. Si, por ejemplo, desea actualizar el valor mientras el usuario está escribiendo, podemos agregar el valor de enlace: dos puntos: evento y especificar el evento en el que queremos activar el enlace de datos. El resultado del código que ve aquí es que cada vez que el usuario escriba un carácter, se actualizará el valor de la propiedad. El comportamiento predeterminado será que el valor se actualizará cuando el usuario toque la entrada. En estos últimos, también podemos influir. Si, por ejemplo, desea actualizar el valor mientras el usuario está escribiendo, podemos agregar el valor de enlace: dos puntos: evento y especificar el evento en el que queremos activar el enlace de datos. El resultado del código que ve aquí es que cada vez que el usuario escriba un carácter, se actualizará el valor de la propiedad. El comportamiento predeterminado será que el valor se actualizará cuando el usuario toque la entrada. En estos últimos, también podemos influir. Si, por ejemplo, desea actualizar el valor mientras el usuario está escribiendo, podemos agregar el valor de enlace: dos puntos: evento y especificar el evento en el que queremos activar el enlace de datos. El resultado del código que ve aquí es que cada vez que el usuario escriba un carácter, se actualizará el valor de la propiedad.

Demostración: trabajar con enlace de datos

Volvamos a Visual Studio y exploremos las diferentes opciones de enlace de datos en acción. En primer lugar, le mostraré el enlace de datos en una aplicación independiente independiente. Una pequeña demostración que no está realmente relacionada con nuestra aplicación completa. Tengo este componente de índice aquí, y tiene una clase de componente, que sería esta clase aquí, la clase de índice, y aquí defino una propiedad de empleado. Como puede ver en OnInitializedAsync, estoy creando un nuevo empleado, estoy creando una instancia de un nuevo empleado, debería decir. Codificado de forma rígida, esto podría provenir de una API, pero no quiero centrarme en esta demostración. La mayor parte de la acción en realidad ocurrirá en las IU, por lo tanto, en el código de Razor, la IU del componente. Primero, déjame mostrarte el enlace de datos unidireccional. Ahora primero, el bloque resaltado aquí usa enlace de datos unidireccional. Voy a mostrar el nombre y apellido del empleado. Y esa sintaxis ya la hemos visto. Lo estoy usando aquí dentro de una etiqueta, por lo que es un control de formulario, y solo estoy usando la sintaxis que hemos usado antes, @Employee.FirstName, @Employee.LastName. Cuando ejecutamos la aplicación, pues este es el resultado. Esto es lo que ves aquí. Estoy mostrándole a Bethany Smith. A continuación, estoy usando un componente de formulario, la entrada aquí. En este caso, también estoy usando un enlace de datos unidireccional, lo que significa que los datos fluirán, vendrán de la fuente, que es esta propiedad aquí, y solo los mostraré dentro de la entrada. Luego uso value= y luego la misma sintaxis que ya hemos visto antes. Ahora, esto es un enlace de datos unidireccional. Eso significa que si cambio algo aquí, realmente no pasará nada. Ahora bien, esto es solo un enlace de datos unidireccional. Los datos provienen de la fuente, la propiedad, pero no los devuelvo cuando cambio algo aquí en la interfaz de usuario. Si quiero que eso suceda, entonces puedo usar el enlace de datos bidireccional donde voy a usar otra sintaxis, estoy usando @bind aquí en esta entrada. Usando @bind aquí, crearemos un enlace, un enlace, entre el componente de entrada y la propiedad en nuestro componente. Si ahora cambio un valor en la interfaz de usuario y toco el componente, verá que todos los demás campos se actualizan porque están vinculados a la misma propiedad, pero eso también significa que cuando ingreso datos en este mismo entrada aquí, los datos se enviaron de vuelta a la fuente. Entonces, los datos se actualizarán cuando toque el componente de entrada. Ese es un enlace, un enlace, entre la interfaz de usuario y la propiedad en nuestra clase de back-end. Ahora también es posible que deseemos enlazar datos en un evento diferente. Por lo tanto, onblur, por lo tanto, tabular fuera del evento, es el valor predeterminado, pero, por ejemplo, digamos que quiero especificar que quiero enviar automáticamente el valor actualizado en la entrada cuando se presiona una tecla, usando esta sintaxis aquí. Ahora uso @bind-value, y luego también puedo especificar qué evento, en este caso el oninput, quiero que se active el enlace de datos. Si ahora hago otra prueba aquí y me ves escribiendo, automáticamente los valores se actualizan. Eso significa que los datos se envían desde el componente automáticamente a la propiedad. También tengo este botón Haz clic aquí. Primero veremos el código. Ese es este botón aquí. Pero el código en realidad, digamos, restablecerá Employee.FirstName a Gill. Si hago clic en eso, verá que los datos se transmiten nuevamente desde la fuente, o desde la propiedad, a la interfaz de usuario de mi componente. Eso es nuevamente desde la fuente hasta la interfaz de usuario.

Creación de un formulario con componentes de entrada

Ahora que sabemos cómo funciona el enlace de datos, echemos un vistazo a la creación de un formulario en nuestra aplicación donde el usuario ahora puede ingresar un nuevo empleado o editar uno existente, y vincularemos esto en la demostración con métodos en nuestra API. . Ya hemos discutido que la entrada de datos en las aplicaciones HTM siempre se basará en un formulario. Si bien podemos usar el formulario HTML normal y la etiqueta de entrada en Blazor, como ya hemos explicado, Blazor viene con una serie de componentes de entrada listos para usar que podemos usar en un formulario y que nos ayudarán a crear nuestros formularios. . El formulario en sí será un EditForm. Para las entradas HTML comunes, existen componentes de entrada Blazor correspondientes. Veremos esto en un minuto. Estos componentes, por supuesto, admitirán, nuevamente, el enlace de datos. Además de eso, también admitirán una validación, que veremos en la parte final de este módulo. Mediante el uso de algunas clases de CSS, estos componentes tienen un comportamiento integrado que, por ejemplo, obtendrá un contorno rojo. Pero si es necesario, podemos personalizar esto. Construyamos un formulario paso a paso ya que hay algunas cosas que entender aquí. Para empezar, la forma. El formulario HTML en sí tiene una versión de Blazor, digamos, EditForm. Es un componente integrado en Blazor. Colocaré nuestros componentes de entrada allí en solo un minuto. Antes de hacer eso, primero debemos configurar el Modelo para EditForm. Y aquí, lo estoy configurando como Empleado. Employee es una instancia del tipo Employee y se expone aquí en la clase de componente de la propiedad Employee. El EditForm creará un EditContext basado en este modelo. Y a través del EditContext, Blazor puede comprobar qué campos dentro del formulario se han editado o qué errores de validación se han producido. La clave aquí es que usamos EditForm y configuramos el Modelo en una instancia aquí de tipo Empleado. Ahora en el formulario, haremos la mayor parte del trabajo. Expondremos la cantidad de componentes para permitir que el usuario ingrese información. Blazor viene, como se dijo, equipado con un amplio conjunto de componentes para permitir la entrada del usuario. Técnicamente, puede verlos como envoltorios alrededor de las entradas HTML existentes. Representarán la entrada HTML correspondiente. Tenemos InputText, que es la versión Blazor de HTML InputType es igual a texto. TextArea también permite la entrada de texto, pero de varias líneas. InputNumber también acepta entradas, pero solo se aceptan valores numéricos. InputSelect crea una selección HTML, por lo que un menú desplegable, y creo que puedes imaginar lo que hará InputDate. A continuación, tenemos InputCheckbox, InputRadio y InputRadioGroup. Este último nos permite agrupar una serie de componentes de InputRadio, y solo se puede seleccionar uno dentro del grupo. Finalmente, tenemos InputFile, que nos permite crear una carga de archivos en nuestras aplicaciones Blazor. Los componentes de entrada de Blazor son, como habrá esperado, componentes. Heredan de la clase InputBase, y una de las cosas que hacen además de representar la entrada HTML correspondiente es agregar soporte para la validación. Cómo funciona esto, depende del componente utilizado. Eso lo veremos en la siguiente parte. Estos componentes de entrada, al igual que sus contrapartes HTML normales, también admiten el enlace de datos bidireccional, sin embargo, con una sintaxis ligeramente diferente. Veamos algo de código. Aquí está nuestro formulario ahora con un solo componente de entrada agregado, un texto de entrada. Para enlazar datos, ahora usamos @bind-Value, y también está configurado en una propiedad a la que podemos enviar los datos a través del enlace de datos. Nuevamente, esto se representará como una entrada HTML y los valores ingresados ​​se enviarán a la propiedad. Tenga en cuenta que podemos y debemos, de hecho, usar atributos HTML normales, como class e id, en los componentes de entrada de Blazor. Estos se copiarán textualmente en la salida renderizada. Aquí puede ver otro componente, InputSelect, que se representará como un cuadro combinado en el menú desplegable. El valor de vinculación apunta a dónde podemos obtener y establecer el valor seleccionado. Las opciones aquí serán países. Vamos a hacer un bucle usando un foreach sobre todos los países. Los países serán una lista en la clase de componente, y para cada uno, vamos a crear una opción. Eso es lo que espera la selección en HTML. El valor se establece en country.countryId y mostramos country.name. También utilizaremos algunas selecciones en la próxima demostración. Por supuesto, una vez que el usuario haya ingresado toda la información, o eso es lo que esperamos al menos, debería poder enviar el formulario. Tenemos un par de devoluciones de llamada disponibles para esto, a las que simplemente podemos adjuntar un controlador de eventos y continuar desde allí. OnValidSubmit se puede usar para activar un controlador de eventos cuando se envía un formulario válido. En otras palabras, se deberá cumplir con la validación integrada y, luego, cuando se envíe el formulario, se llamará al controlador de eventos vinculado. OnValidSubmit funciona en conjunto con OnInvalidSubmit, que se activará si envía el formulario con campos aún no válidos. También podemos optar por activar el código, independientemente de si el formulario es válido o no. Para eso, tenemos OnSubmit, y en el controlador de eventos, podemos manejar la validación manualmente. En nuestra demostración, usaremos OnValidSubmit y OnInvalidSubmit. Aquí está el formulario actualizado, que ahora contiene OnValidSubmit y OnInvalidSubmit. Ambos apuntan a un controlador de eventos, básicamente un método, en la clase de componente.

Demostración: creación de un formulario

Es hora de una gran demostración, de hecho, una demostración de tres partes. En esta primera parte, vamos a crear un formulario usando componentes de Blazor. Usaremos un formulario tanto para agregar un nuevo empleado como para actualizar uno existente. Apliquemos ahora lo que hemos aprendido sobre la minería de datos y sobre los formularios y creemos ese formulario de empleado nuevo/editado. voy a hacer eso Voy a crear un nuevo componente, un componente de página. Va a ser una página, un componente de relleno de pantalla, debería decir. Así que vayamos aquí y creemos un nuevo Razor Component, y lo llamaré EmployeeEdit. De hecho, voy a crear un componente que pueda manejar tanto la creación de nuevos empleados como la actualización de los empleados existentes. Y, en esa área, nada está cambiando. Voy a crear también una clase de back-end o una clase de componente y la llamaré EmployeeEdit. maquinilla de afeitar.cs. Ahora, este EmployeeEdit, como se mencionó, lo que va a hacer me permitirá crear y actualizar los empleados existentes. Eso significa que probablemente volveré a trabajar con el EmployeeDataService que creamos anteriormente. Así que vamos a inyectar un IEmployeeDataService aquí nuevamente. Si observamos esa interfaz, vemos GetAllEmployees y GetEmployeeDetails. Ya los hemos usado, pero también definió Add, Update y DeleteEmployee. Creo que todavía tenemos que implementarlos, pero lo haremos más tarde. Ahora, EmployeeEdit también recibirá posiblemente, digamos, una identificación de un empleado que quiero editar. Y espero que ya recuerdes eso, que vamos a capturar dentro de un Parámetro. Va a ser una cadena EmployeeId anulable. Puedo recibir uno si estamos en modo de edición. También es posible que no reciba uno cuando estemos en el modo de creación y en el modo de adición. Otra cosa que voy a hacer es crear una propiedad de Empleado, y eso se usará para vincular la fecha de mi interfaz de usuario en mi formulario, debería decir. Por ahora, tengo suficiente aquí. Voy a ir primero a mi componente EmployeeEdit Razor, desechar lo que ya está allí y luego comenzar a construir este componente. Quiero poder llegar a este componente usando la navegación. Quiero poder navegar a employeeedit. Pero también quiero poder navegar a esta pantalla pasando un EmployeeId, así que agregaré otro segmento aquí y pondré allí el nombre de la variable a la que quiero que se dirija este valor, que era EmployeeId, y eso corresponde con este Parámetro aquí. Entonces, en otras palabras, cuando paso el EmployeeId, este parámetro recibirá ese valor. Y la forma en que organizo las cosas aquí hace que este sea un parámetro opcional, puedo navegar a employeeedit, o puedo navegar a employeeedit pasando un EmployeeId. Eso distinguirá entre crear o actualizar un empleado existente. Ahora, vamos a crear el diseño de mi pantalla, que será principalmente un formulario, pero también quiero agregar un título. Entonces, primero agregaré un h1 aquí, y nuevamente usaré lo que ya sabemos sobre el enlace de datos, estoy usando el enlace de datos unidireccional aquí para obtener los valores de la fuente de la propiedad Empleado, entonces puedo decir Detalles para @Employee.FirstName y @Employee.LastName. Muy bien, a continuación, voy a crear un EditForm. Aquí vamos. Ahora tenemos nuestro formulario. Que vamos a estar ligando a una propiedad Employee o Employee, esta de aquí, y que será utilizado por el formulario también para realizar la validación más adelante. De hecho, OnValidSubmit se activará cuando el empleado ya no tenga ningún error de validación en el formulario. Hablaremos sobre la validación más adelante, pero sepa que esta propiedad del Modelo que vamos a agregar aquí es muy importante para la validación. Así que voy a especificar el modelo aquí para que sea @Employee. Una vez más, esto realmente se refiere al Empleado, no al tipo, así que me estoy refiriendo a la instancia, no a la clase. Ahora podemos usar componentes de entrada. Y como ya expliqué, podríamos usar las entradas HTML normales, pero es mucho más fácil usar los componentes de entrada integrados de Blazor. Ya admiten cosas como la validación, entonces, ¿por qué no usar esos? Comenzaré creando un primer InputText para capturar el apellido del empleado. Estoy usando un código de arranque regular nuevamente. Y luego, aquí, estoy usando InputText. Le doy una identificación. Le doy una clase, por lo que todos estos atributos se cubrirán palabra por palabra en la entrada resultante. Entonces, InputText es realmente solo un envoltorio alrededor de InputType como texto. Pero, por supuesto, no he especificado ahora a qué se vinculará esto. Necesito hacer eso ahora. Debido a que este es uno de los componentes de entrada incorporados, no puedo usar @bind. Necesito usar @bind‑Value. Así que escribo @bind-Value y luego especifico a qué se va a vincular. Quiero vincular esto a @Employee.LastName. Ahora voy a pegar un fragmento que contiene, bueno, bastantes otros campos, pero son muy similares. ¿Qué pegué? Permítanme primero formatear las cosas correctamente de nuevo. Aquí vamos. Así que agregamos @Employee.LastName, ahora incorporé lo mismo para @Employee.FirstName, la fecha de nacimiento, que en realidad se unirá a InputDate, que se representará como un selector de fecha. Tengo un InputText para el correo electrónico, uno para la calle, otro para el código postal y otro para la ciudad. Entonces, a excepción de InputDate, esos fueron todos InputTexts. Ahora, en este punto, me gustaría ejecutar las cosas para ver si estamos haciendo un buen trabajo, pero todavía no tengo los datos de los empleados, así que voy a volver aquí y voy a cree una anulación aquí para OnInitializedAsync nuevamente. Porque vamos a utilizar nuestro servicio de datos para obtener datos de la API, Digo que este empleado necesita obtener sus datos del EmployeeDataService llamando a GetEmployeeDetails, pasando el EmployeeId, Parsed como un número entero. Nota importante aquí, esto no funcionará si estamos agregando. Hablaremos sobre agregar más tarde, así que volveré a este código más adelante. Solo quiero probar cosas en este punto. También necesito hacer esto asíncrono, por supuesto. Y si ejecutamos la aplicación ahora, ya deberíamos poder navegar a la página EmployeeEdit, pasando, por supuesto, una identificación de un empleado existente. Así que aquí está nuestra pantalla. No tengo ninguna manera de navegar a esta página. Lo haremos en un minuto. Así que necesito navegar escribiendo employeeedit y luego la ID, y eso es solo 1. Y ahí vamos. Ahora tenemos nuestros datos de nuestra API. Eso está cargando en este formulario, lo que me permite escribir. Y como podemos ver aquí, puedo escribir, no guardar nada todavía, pero puedo cambiar los valores aquí o usar el enlace de datos en combinación con el envío de datos a nuestra API en solo un minuto. Ahora, por supuesto, hay bastantes otros campos en el modelo del Empleado, como podemos ver aquí, así que este era un tipo. Tenemos el País, el Número de teléfono, etc. Hay bastantes especiales aquí. Sigamos agregando entradas a nuestro formulario, y el primero que quiero agregar ahora es el País. Dado que, por supuesto, Country no es texto libre, voy a usar una selección e InputSelect, ese es el componente que obtenemos con Blazor. InputSelect espera una serie de opciones que necesito para pasarlo. Eso en realidad puede ser dinámico. Lo haremos en un minuto. Pero también requiere que obtengamos esos países de la API. Incluí en la API un CountryController que tiene la capacidad de devolver simplemente todos los países que tenemos en la base de datos. Pero todavía no tengo una forma de llamar a eso desde una aplicación Blazor, así que lo haremos a continuación. Entonces, primero, vayamos a EmployeeEdit y digamos que vamos a usar aquí una Lista de países. Todavía no tengo los datos para eso, así que seguiré algunos pasos para obtener acceso a los datos que provienen de nuestra API. Entonces, como en la aplicación Blazor, en la carpeta Servicios, de una manera muy similar a lo que hicimos con el empleado, también usaré un ICountryDataService. Eso es, por supuesto, nuevamente, va a ser una interfaz. Va a ser una interfaz muy simple que obtiene todos los países o es capaz de obtener un país por ID. Y, por supuesto, también crearemos una implementación de una sola vez, así que permítanme traer también CountryDataService. Voy a pegar el código de CountryDataService y lo guiaré. No hay nada realmente nuevo que aprender aquí. Así que aquí tenemos CountryDataService, que usa HttpClient nuevamente. Eso se inyectará usando IHttpClientFactory. Tendremos que ir a la clase Program para registrar eso. En GetAllCountries, estoy usando, nuevamente, _httpClient.GetStreamAsync, pasando api/country para obtener JSON de todos los países, y que voy a deserializar en este IEnumerable de países. Dije que necesito volver a registrar este servicio en el Programa. De manera muy similar, voy a registrar aquí que cuando alguien pida un ICountryDataService, voy a devolver un CountryDataService. Y como usé AddHttpClient, se volverá a inyectar una instancia de HttpClient. Eso significa que en nuestro componente, ahora puedo usar ICountryDataService. También voy a inyectar una instancia de esa interfaz. Ya creé mi lista de países, que ya está aquí, así que ahora puedo obtener los países del servicio de datos que saldrán a nuestra API. Ahora, puedo volver a la interfaz de usuario de mi componente. Y ahora, puedo escribir el código correcto para mi InputSelect. Observe que ahora he agregado un foreach que recorrerá todos los países y agregará una nueva opción para cada país que podamos encontrar, mostrando el nombre del país y teniendo como valor el país.ID del país. Observe, de nuevo, que también estoy usando un enlace bidireccional aquí. Este InputSelect se vinculará de dos maneras a la propiedad CountryId de nuestro Empleado. Eso significa que cuando selecciono un nuevo país, que su valor se transmitirá de vuelta al empleado vinculado. Pero también, al cargar la pantalla, se seleccionará el país correcto si se encuentra en la lista de opciones. También teníamos en el Empleado la Categoría de trabajo. Voy a utilizar un enfoque muy similar para obtener estas JobCategories. Te voy a mostrar el resultado. Y amplié mi componente con un IJobCategoryDataService inyectado. Es más o menos lo mismo que CountryDataService, GetAll y get by Id. La implementación es muy similar de nuevo. También estamos inyectando un httpClient a través de la inyección del constructor, todo obteniendo todas las categorías de trabajo. Para que no olvidemos registrar eso también con la colección de Servicios. Y también creé una lista de JobCategories, y también la cargué desde la API. Ahora, con JobCategoryDataService agregado, Permítanme volver a la interfaz de usuario y agregar más código allí. Pegué un fragmento bastante grande y lo explicaré ahora. Tenemos un texto de entrada para el número de teléfono que se une al número de teléfono. Un InputNumber tanto para la latitud como para la longitud. InputNumber se usa para ingresar valores numéricos solamente. Solo permitirá introducir valores numéricos. Luego tengo un InputCheckbox para vincular a Boolean Value Smoker, así que sí o no, verdadero o falso. Tengo otro InputSelect, que mostrará JobCategories, de manera similar a como lo hicimos con los países. A continuación, estoy usando un InputRadioGroup para generar botones de opción para cada valor en la enumeración Sexo. Quiero limitar a los usuarios a hacer una sola selección entre las posibles opciones que ofrezco. Tengo un par de InputRadios, que se generan en un bucle foreach para cada uno de los géneros definidos en la enumeración. Aquí estoy usando otro InputSelect que vincula el estado civil de nuestro empleado. Y esta vez, no estoy usando un foreach, sino que estoy usando las opciones codificadas y vinculadas a las diferentes opciones en la enumeración MaritalStatus. Tengo un par de InputDates, uno para JoinedDate y otro para ExitDate. Y finalmente, estoy usando InputTextArea para mostrar un cuadro de comentarios. Esto se representará como un área de texto de varias líneas. Una pequeña cosa, agregué esta declaración de uso aquí en la parte superior debido a las enumeraciones que estoy usando aquí en el código de Razor. Hagamos ahora posible navegar a esta pantalla. Voy a ir al NavMenu y voy a agregar otro NavLink aquí. Esto generará otro enlace en mi menú y me permitirá agregar un nuevo empleado simplemente navegando a employeeedit. Pero nuestra página también permite a los usuarios agregar empleados existentes, por lo que también quiero poder navegar desde la vista general de empleados hasta la pantalla de edición de empleados. Y si pensamos en cómo lo hicimos, necesito ir a mi componente EmployeeCard. Y allí, agregaremos otro botón que me permita navegar a la edición de empleados, pasando el Id. de empleado. Así que ahora tengo la capacidad de navegar para crear o editar, pero mi pantalla aún no reacciona correctamente. Así que voy a volver a mi EmployeeEdit, y la línea que agregué originalmente aquí, la voy a eliminar. Voy a ir aquí y decir que quiero analizar el EmployeeId usando este TryParse aquí. Si el IdEmpleado es 0, eso significa que estamos creando un nuevo empleado, no se pasó ningún parámetro. Y luego también configuré algunos valores predeterminados, de lo contrario, todavía voy a mi API y obtengo los detalles del empleado. Eso fue bastante código. Intentemos asegurarnos de que todo funciona correctamente. Ya vemos un botón para agregar un nuevo empleado. Primero, voy a hacer clic aquí en Empleados, y también veo el botón Editar aquí. Hagamos clic en eso primero. Esto irá a mi API y obtendrá todos los detalles necesarios. También ha establecido una categoría de trabajo y los menús desplegables de país correctamente. Eso parece estar bien. Y también vemos el cuadro de texto de varias líneas, así como las fechas de entrada. Si hago clic en Agregar nuevo empleado, veremos que tenemos una pantalla en blanco y puedo comenzar a agregar los detalles de un empleado aquí. Todavía no tenemos la capacidad de salvar a un empleado. Haremos eso a continuación.

Demostración: Guardar datos

En la próxima demostración, actualizaremos nuestra aplicación para que se guarden los cambios. Ahora, quiero poder enviar el formulario para que el usuario pueda guardar un nuevo empleado o actualizar uno existente. En la definición de EditForm, voy a incorporar dos controladores de eventos, OnValidSubmit y OnInvalidSubmit. El OnValidSubmit, lo manejaré en un método que necesito crear yo mismo. Voy a llamar a eso HandleValidSubmit. Todavía no tenemos eso, así que obtenemos una pantalla roja; lo agregaremos en solo un minuto y, de manera muy similar, manejaré el envío no válido a través de HandleInvalidSubmit. Entonces, lo que significa usar OnValidSubmit y OnInvalidSubmit es que se llamará al método correcto en función de la validación realizada por EditForm, y para eso buscará al empleado. Si el empleado no me da ningún error de validación, se llamará a ValidSubmit; si hay errores de validación, pues bien. se puede llamar al InvalidSubmit. Para hacer feliz a Visual Studio, agreguemos ambos métodos ya. Entonces, los tres controladores de eventos están ahora. En HandleValidSubmit, nuevamente necesito saber qué estamos tratando de hacer en la pantalla. Según el valor de EmployeeId, crearé un nuevo empleado o actualizaré uno existente. Para poder enviar, también necesito volver a mi formulario, desplazarme hacia abajo y aquí, también voy a agregar un tipo de botón "enviar". No hay nada de Blazor en todo esto. Esto solo activará el envío sobre el formulario en HTML. Ahora pienso, y todavía no tengo una implementación para AddEmployee. De hecho, si presiono Ctrl+F12 en eso, vemos que aún no tenemos una implementación para agregar, eliminar y asumir actualizaciones. Agreguemos esos a continuación. Voy a mostrarles aquí lo que estoy haciendo con la adición de un nuevo empleado. Primero voy a serializar al empleado que estoy pasando a JSON, que voy a publicar a través del cliente HTTP pasado a api/employee. La API sabrá que cuando se recibe una publicación, debe activar el código correcto, y ese código es este código aquí. Vamos a llamar a CreateEmployee pasando un empleado como JSON cuando se reciba una publicación. Si la respuesta es exitosa, si obtenemos un 200, entonces vamos a deserializar lo que obtenemos; de lo contrario, devolveremos un valor nulo. De esta manera, nuestro código, nuestro código de llamada, debería decir, sabrá si las cosas fueron bien o no. Aquí está la Actualización y el DeleteEmployee. No hay nada realmente especial sucediendo aquí. Volvamos a nuestro componente. Voy a agregar algunos campos para trabajar con el estado. Quiero mostrar en la interfaz de usuario el CSS correcto y el mensaje correcto, y lo haré usando estos campos aquí. El campo Guardado, lo usaré para verificar si las cosas ya se guardaron, se agregaron o actualizaron, o no. Inicialmente, por supuesto, vamos a configurarlo como falso. Voy a extender un poco el código en HandleValidSubmit para poder trabajar con estos campos. Entonces, cuando se realiza el envío y el formulario dice, bueno, todo está bien, no hay errores de validación, entonces voy a activar este código. Es una versión extendida de lo que ya teníamos, para ser honesto. Nuevamente, estamos comprobando si EmployeeId es 0, luego voy a agregar un nuevo empleado, llamando a nuestro EmployeeDataService que saldrá a la API. Si AddEmployee no es nulo, lo que significa que recibimos algo de AddEmployee, entonces estableceremos StatusClass, que es solo una cadena, para alertar sobre el éxito. Vamos a establecer el Mensaje y vamos a establecer Guardado en verdadero. Si AddEmployee fue nulo, bueno, voy a establecer StatusClass en alerta de peligro. Esas son clases de Bootstrap. También voy a configurar un mensaje diferente y voy a configurar Guardado en falso. Y aquí vemos el código actualizado para actualizar un empleado. Vamos a ejecutar esto en solo un minuto, pero primero, por supuesto, también necesito implementar HandleInvalidSubmit. Soy responsable de hacer eso, porque lo he definido ahora en mi código. aquí, Voy a configurar también StatusClass y Message. Ahora volvamos a la interfaz de usuario de nuestro componente y vamos a usar estos campos. Primero usaré el campo Guardado para verificar si el formulario debe mostrarse o no. Entonces, lo que voy a hacer es envolver toda la sección que contenía mi formulario también, dentro de un bloque if. Voy a decir @if. Voy a mostrar que cuando Guardado es falso. Entonces, cada vez que Guardado es falso, quiero mostrar mi sección original que contenía el formulario. De lo contrario, bueno, entonces, si Guardado es cierto, no necesito mostrarlo más. Lo ocultaré y luego mostraré un mensaje. Voy a usar una alerta de "clase div" @StatusClass que obtuvo este valor, alerta-peligro o alerta-éxito; También voy a mostrar el valor de Message. Por lo tanto, este bloque solo se mostrará cuando Guardado sea verdadero. Y antes de ejecutar esto, permítanme agregar también soporte para eliminar. Aquí está nuestro botón Guardar de nuevo. También quiero mostrar un botón Eliminar, pero solo quiero mostrarlo si el Id. de empleado es mayor que 0. No podemos eliminar a un empleado que aún no hemos agregado. Cuando se hace clic en ese botón, no activaré el envío del formulario, lo manejaré con otro controlador de eventos, DeleteEmployee. DeleteEmployee va a usar el EmployeeDataService nuevamente y llamará a DeleteEmployee en eso. Vamos a configurar StatusClass y Message, y también Saved se establece en true, lo que ocultará todo el formulario nuevamente. Casi estámos allí. Hay una cosa más que quiero agregar aquí. Si las cosas no se guardan correctamente, De hecho, me voy a quedar atrapado con esta parte aquí en la pantalla. También quiero poder navegar de regreso a la vista general, digamos. He agregado aquí un botón con @onclick NavigateToOverview. Voy a navegar programáticamente de regreso a la pantalla de Descripción general. Ya hemos visto cómo podemos hacer eso. Navegar mediante programación significa que necesito traer el Administrador de navegación, por lo que voy a usar la inyección de dependencia una vez más para traer una instancia de NavigationManager. Ahora puedo escribir la implementación para @NavigateToOverview. De hecho, ya lo hemos visto. Ahora puedo llamar a NavigationManager.NavigateTo y pasar la URL a la que quiero navegar. Y para ser realmente completo, puedo, de hecho, también desde la pantalla Crear, agregar un botón Cancelar que, de hecho, también navega de regreso a la vista general. Aquí vamos. Probemos esto. Espero haber hecho todo correctamente y que ahora podamos agregar y editar empleados con éxito. Comencemos agregando un nuevo empleado. Voy a completar algunos detalles. Ahora he introducido algunos detalles. Vemos que el botón Eliminar no se muestra porque el Id. de empleado no es mayor que 0, y haré clic en Guardar empleado, y el formulario está oculto, y vemos el mensaje de estado que se muestra en la parte superior. Ahora puedo hacer clic en Volver a la vista general y he agregado correctamente a un empleado. Intentemos editarlo. Vamos y agregamos aquí Test. Ahora podemos eliminarlo, y también ahora podemos guardarlo de nuevo, y ahí vamos. Vemos el valor actualizado. Una cosa a tener en cuenta aquí. Si su caché aún no se ha borrado, aún puede ver el valor anterior.

Demostración: Subir una imagen

A continuación, ahora permitiremos que los usuarios carguen una imagen para los nuevos empleados. Usaré para eso el archivo de entrada. Quizás estés pensando, ¿de dónde salió esa imagen? No subió uno. Bueno, eso lo arreglaremos ahora. Voy a permitir que el usuario, al crear un nuevo empleado, también incluya una imagen. Para mantener las cosas simples, solo voy a permitir que el usuario seleccione una imagen cuando se crea un nuevo empleado, y para eso uso aquí un InputFile, que cuando OnChange llamará al código, OnInputFileChange. Todavía no tengo eso, así que agreguemos eso ahora. En OnInputFileChange, recuperaré InputFileChangeEventArgs. Espero que recuerde que podemos obtener algunos argumentos de eventos predeterminados, bueno, para el archivo de entrada que es del tipo InputFileChangeEventArgs. Eso me dará acceso al archivo seleccionado por el usuario. De hecho, el navegador y por lo tanto también nuestra aplicación Blazor, obtendrá acceso al archivo seleccionado en el navegador. Entonces, en este punto, mi aplicación Blazor tiene acceso al archivo, pero todavía no tengo la capacidad de almacenar esa imagen. Voy a cambiar eso. Voy a ampliar mi tipo de empleado con una matriz de bytes y un nombre de imagen. Vayamos al Proyecto compartido, Dominio y Empleado. Como dije, voy a ampliar esto con una propiedad ByteArray, ImageContent y ImageName. He agregado aquí también NotMapped. El NotMapped que estoy usando porque no quiero almacenar la imagen en la base de datos. Quiero almacenar la imagen en el sistema de archivos. Te lo mostraré en un minuto. Ahora, con eso agregado, también necesito asegurarme de que mi base de datos esté sincronizada nuevamente. Voy a crear una migración. Con la API seleccionada como proyecto predeterminado, voy a crear una migración especificando aquí en la consola del Administrador de paquetes, agregar migración. Voy a decir aquí, ImageAdded. Ese es el nombre de la migración. Se activará una compilación y se creará la migración. De hecho, podemos ver en la migración que solo se agregó una columna para ImageName. Ahora, con la migración agregada, actualicemos la base de datos para ejecutar la migración, por supuesto, y ahora se ha ejecutado correctamente. Ahora, en mi componente, en HandleValidSubmit, necesito escribir algo de código. Si el archivo seleccionado, ese era este aquí, no es nulo, en otras palabras, si el usuario ha seleccionado un archivo, voy a leer ese archivo en la aplicación Blazor, y eso lo hago usando este código. aquí. Luego especifico ImageName para que sea el nombre del archivo, y ImageContent se establece en la matriz, la matriz de bytes, del archivo de imagen en ejecución. Eso ahora se enviará a mi punto final de API, pero todavía no sabe acerca de esa imagen entrante, por lo que también necesito hacer un cambio allí. Es posible que haya notado que ya había algún código comentado, código sin comentar que creé para que pueda manejar la lectura de una imagen en la API. Este código almacenará la imagen en el servidor. Voy a crear una ruta al nombre del archivo basada en employee.ImageName. Luego voy a leer el flujo de archivos. Luego voy a crear un flujo de archivos y voy a escribir en él el contenido de la imagen que vino como parte del empleado. Y finalmente, guardo el ImageName actualizado en el empleado antes de guardarlo en la base de datos. Las imágenes cargadas se almacenarán en esta carpeta Cargas en wwwroot. Esa carpeta ya estaba allí, si estás usando mi proyecto. Una cosa más, volvamos a nuestra EmployeeCard, y verá lo que estoy usando actualmente para mostrar las imágenes. Tengo esta etiqueta de imagen y luego uso una cadena concatenada, pasando el EmployeeId.jpg. Así que ya tenía varias imágenes allí. Voy a reemplazar eso con lo que ves aquí. Ahora voy a establecer la fuente de la imagen en ImageName. En el controlador, almaceno la ruta completa a la imagen cargada. Entonces, por supuesto, los empleados ya existentes ya no trabajarán, pero intentemos agregar uno nuevo, y deberíamos ver esa imagen cargada. Cuando volvemos a ejecutar la aplicación y hacemos clic en Agregar nuevo empleado, ahora podemos ver que tenemos la posibilidad de elegir un archivo. Seleccionaré una imagen. Permítanme introducir algunos detalles aquí. Hagamos clic en Guardar empleado. Eso funcionó con éxito. Si volvemos a la Vista general ahora, veremos que faltan un par de imágenes. Esos están usando los enlaces antiguos, pero George, sin embargo, muestra una imagen, y esa es la imagen cargada. Si buscamos en Visual Studio en la carpeta Cargas, efectivamente vemos que se ha cargado person1.

Agregar validación

En la parte final de este módulo, veremos cómo podemos ampliar nuestro formulario para que también admita la validación. Básicamente, obtenemos la validación de forma gratuita con los componentes de entrada y EditForm integrados de Blazor. Sin embargo, hay algunos pasos que debemos seguir para que la validación funcione. En primer lugar, de forma predeterminada, las validaciones se pueden agregar fácilmente mediante anotaciones de datos. También podemos usar otras opciones aquí, pero para simplificar las cosas, nos basaremos en las anotaciones de datos. Si no sabe cuáles son, se los mostraré en la siguiente diapositiva. Luego, Blazor viene con DataAnnotationsValidator, un componente, por supuesto, que se usa para brindar soporte para validaciones basadas en anotaciones de datos. Simplemente necesitaremos agregarlo a nuestro EditForm. Como se dijo, si desea realizar otro tipo de validación, deberá escribir una validación personalizada aquí. Finalmente, el tercer bloque de construcción para habilitar la validación es ValidationSummary. Este componente le dará una visión general, un resumen, de todos los errores de validación que tenemos en nuestro EditForm. Aquí puede ver que se están agregando anotaciones de datos a nuestras entidades. Tenemos la propiedad LastName de la clase Employee, y está decorada con dos atributos de validación, las llamadas anotaciones de datos. La anotación de datos requerida hará que esta propiedad sea obligatoria, por lo que si intentamos enviar el formulario sin el valor ingresado en el componente de entrada vinculado, este atributo provocará un error de validación. De manera similar, StringLength se asegurará de que la longitud del valor ingresado no supere los 50 caracteres, quizás debido a una restricción en la base de datos. Opcionalmente, al agregar la anotación de datos, también podemos pasar un mensaje de error, como podemos ver aquí. Esto incluso se puede localizar si se trabaja con una aplicación multilingüe. Para que funcione la compatibilidad con la validación de anotaciones de datos, debemos agregar DataAnnotationsValidator. Simplemente coloque esto en EditForm y todo estará bien. El resultado es que la validación se activará cuando el usuario salga del campo y cuando haya errores de validación en el formulario, enviar el formulario no activará HandleValidSubmit. Ahora los errores de validación no se visualizarán automáticamente. En su lugar, debemos traer ValidationSummary. Eso generará, por defecto, una lista de todos los mensajes de error que tenemos en el formulario. El resultado es que la validación se activará cuando el usuario salga del campo y cuando haya errores de validación en el formulario, enviar el formulario no activará HandleValidSubmit. Ahora los errores de validación no se visualizarán automáticamente. En su lugar, debemos traer ValidationSummary. Eso generará, por defecto, una lista de todos los mensajes de error que tenemos en el formulario. El resultado es que la validación se activará cuando el usuario salga del campo y cuando haya errores de validación en el formulario, enviar el formulario no activará HandleValidSubmit. Ahora los errores de validación no se visualizarán automáticamente. En su lugar, debemos traer ValidationSummary. Eso generará, por defecto, una lista de todos los mensajes de error que tenemos en el formulario.

Demostración: Adición de Validación

Volver a Visual Studio por última vez en este módulo. Agregaremos anotaciones de datos y habilitaremos la validación en nuestro formulario. Ahora solo podríamos agregar empleados y, de hecho, omití algunas propiedades al crear nuestros nuevos empleados. Es porque en nuestro empleado en este punto, todavía no tenemos ninguna lógica de validación. Voy a agregarle a nuestro empleado algunas anotaciones de datos y agregaré algunas anotaciones de datos. Obtenemos algunos garabatos rojos, por lo que debemos ingresar la declaración de uso correcta. Aquí vamos. Así que ahora he agregado algunas anotaciones de datos en nuestro tipo de Empleado. Ahora el primer nombre tiene Required y StringLength. Requerido, por supuesto, significa no enviar esto sin el primer nombre; eso le dará una excepción de validación, y StringLength especifica que la longitud no debe exceder los 50 caracteres, y también especificamos un mensaje de error, en caso de que eso suceda. He hecho lo mismo para LastName. También agregué un Obligatorio y una Dirección de correo electrónico al correo electrónico que validarán que la cadena es efectivamente un correo electrónico, y también en el comentario del Editor y en StringLength, diciendo que el usuario no puede agregar un comentario que tenga más de 1000 caracteres. Y solo agregar estas anotaciones de datos no será suficiente. También debemos volver a nuestro formulario y especificar que debe funcionar con estas anotaciones de datos. Así que volvamos a nuestro EmployeeEdit, y dentro del formulario primero para especificar que queremos trabajar con anotaciones de datos, necesito traer el DataAnnotationsValidator. Este adjuntará su soporte de validación mediante anotaciones de datos. Si desea utilizar otra forma de validación, puede hacerlo, pero luego tendrás que usar un validador personalizado. En este punto, si ejecutamos las cosas ahora, no veremos nada todavía. También quiero visualizar mis errores de validación. Para eso, podemos usar ValidationSummary. Si conoce ASP.NET Core, esto le resultará bastante familiar. Esto mostrará una lista de todos los errores de validación en el formulario. También puedo mostrar errores de validación justo al lado de la entrada infractora. Para eso, obtenemos otro componente, el componente ValidationMessage. Aquí ahora he usado el componente ValidationMessage que dice que los mensajes de validación deben mostrarse para Employee.LastName. Y puedo hacer lo mismo para el FirstName, para el Email y, finalmente, también para los Comentarios; ese es el otro donde hicimos la validación. Aquí vamos. Ejecutemos las cosas ahora y veamos si esos errores de validación se muestran correctamente. Agreguemos un nuevo empleado. Ahora, simplemente intentemos enviar el formulario sin ingresar ningún valor. Eso ahora me dará algunos errores. Verá los errores de validación que se muestran aquí en la parte superior. Eso se debe al resumen de validación, y estos mensajes de validación se muestran debido al componente ValidationMessage. Ahora hemos agregado con éxito la validación a nuestro formulario.

Resumen

Y hemos llegado al final de otro módulo más. Hemos cubierto en este módulo cómo nuestros usuarios podrán ingresar datos usando EditForm, un contenedor alrededor del formulario. Dentro del formulario, hemos utilizado los componentes de entrada, que admiten el enlace de datos, el enlace de datos bidireccional para ser claros. Y finalmente, hemos visto cómo podemos agregar validaciones a nuestro formulario, y aquí hemos usado validación basada en anotaciones de datos. En el siguiente módulo, ampliaremos la replicación con la interoperabilidad de JavaScript para incorporar las funciones que faltan.