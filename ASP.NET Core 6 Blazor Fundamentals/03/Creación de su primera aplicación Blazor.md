# Creación de su primera aplicación Blazor

Cátedra Programación de Software y Programática - Fundamentos de ASP.NET Core 6 Blazor

Introducción al módulo

Bienvenido a un nuevo módulo en el curso Fundamentos de Blazor 6 aquí en esta aula de clase. En el módulo anterior, ya se le presentó la plataforma y, de hecho, ya vio un primer componente muy básico. Ahora es el momento de comenzar a escribir código Blazor, y eso es exactamente lo que haremos en este módulo. Al final de este módulo, de hecho, ya tendremos una primera versión funcional de nuestra aplicación, que contiene los primeros componentes reales. Veamos cómo abordaremos las cosas en este módulo. Lo primero es lo primero, cuando creamos una aplicación Blazor, las cosas se verán familiares, pero también contendrá algunas cosas nuevas, por lo que comenzaremos explorando un nuevo proyecto Blazor en blanco primero. Y luego, como se dijo, comenzaremos a construir nuestra aplicación, que contiene un primer componente de construcción propia. Tendremos que dedicar algún tiempo a mejorar el diseño también para que se vea como lo que le mostré en el módulo anterior. Para finalizar este módulo, dedicaremos un tiempo a ver cómo podemos depurar nuestra aplicación Blazor. Aunque no es muy diferente, hay algunos aspectos interesantes para aprender más.
	

Exploración de un nuevo proyecto de Blazor

Pero como se dijo, comenzaremos explorando un proyecto de Blazor recién horneado cuando salga del horno de Visual Studio. Cuando dejamos que Visual Studio ejecute File, New Project, y seleccionamos la plantilla Blazor WebAssembly, que es la que usaremos en este curso, esto es lo que obtendremos. Cuando vimos las aplicaciones en ejecución en el módulo anterior, ese era el código que se estaba ejecutando. La nueva plantilla ya nos da una aplicación de trabajo. Cuando miramos la captura de pantalla aquí que contiene la solución expandida en Visual Studio Solution Explorer, verá principalmente archivos Razor y archivos C#. De hecho, no se ve JavaScript, aunque estamos creando una aplicación de navegador del lado del cliente. Si está familiarizado con ASP.NET Core, también verá muchas similitudes. Podemos ver la carpeta wwwroot y un Program.cs. De hecho, la carpeta wwwroot, al igual que en el proyecto ASP.NET Core MVC, por ejemplo, contendrá los archivos estáticos, pero ahora para nuestra aplicación Blazor. La mayor novedad son los archivos Razor. Los archivos de Razor son componentes de Razor. Los componentes de Razor son el componente principal de cualquier aplicación Blazor. Blazor es un marco basado en componentes. Todo será un componente de Blazor, desde un componente de botón hasta una página completa e incluso el diseño de nuestras páginas. Todos los componentes de Razor tendrán la extensión Razor, como también podemos ver en la captura de pantalla aquí. En los componentes de Razor, usaremos la sintaxis de Razor. La sintaxis de Razor no solo se usa en las aplicaciones de Blazor, sino que también las páginas de Razor y el marco MVC usan esta sintaxis. Si lo conoce de otra tecnología, bueno, buenas noticias, es casi lo mismo aquí. Si nunca lo has usado, pues no te preocupes, lo aprenderemos en el camino. No es muy difícil. Cuando hablamos de los componentes de Razor, de hecho, no solo hablamos de la interfaz de usuario. Los componentes de Razor, de hecho, contienen la interfaz de usuario y la lógica que controla la interfaz de usuario. Si, por ejemplo, en la interfaz de usuario de un componente, tenemos un botón en el que el usuario puede hacer clic, el código de gestión de eventos también forma parte del componente. Podemos colocar este código, por lo que será código C#, dentro del mismo archivo de Razor que contiene la lógica de la interfaz de usuario. Sin embargo, generalmente se recomienda colocar ese código en una clase separada y en un archivo separado y, a menudo, se lo denomina clase de componente o clase de código subyacente. Es importante comprender que cuando se usan componentes de Blazor, el código se ejecuta en el cliente. Y cuando hacemos clic en ese botón, no habrá una solicitud que se envíe al servidor y la respuesta regrese. Toda la lógica se maneja en el cliente y no hay un modelo de solicitud/respuesta cuando se usa Blazor. Construiremos bastantes componentes en cualquier aplicación Blazor. Como se mencionó, todo, desde una página hasta un solo botón, se ve como un componente en Blazor. Eso significa que anidar componentes es algo muy normal. El componente Página contendrá otro componente, y éste a su vez puede contener otro componente más, y así sucesivamente. Los componentes ayudan a dividir la aplicación en bloques más pequeños, y estos se pueden reutilizar fácilmente en toda la aplicación. Pero incluso puede colocar componentes en una biblioteca separada y hacer referencia a eso para múltiples aplicaciones. Por lo tanto, los componentes nos brindan la capacidad de dividir elementos grandes en la interfaz de usuario en bloques más pequeños, y estos se pueden compartir, incluso entre aplicaciones. Al compilar nuestra aplicación, los componentes, por lo que el archivo Razor, también activará la creación de una clase. También es por eso que nuestras clases de componentes necesitarán ser clases parciales, como veremos pronto. Una cosa pequeña pero importante a tener en cuenta al crear componentes, por lo que el archivo Razor, el nombre del componente, debe comenzar con mayúsculas. Así que tenga cuidado al crear nuevos componentes. Veamos ahora el código de un primer componente simple. De hecho, ya vimos esto brevemente en el módulo anterior. Este es el código que se generó al ejecutar Archivo, Nuevo Proyecto. Es el código del archivo Counter.razor y, de hecho, es un componente. Es un componente al que podemos navegar ya que tiene una directiva de página en la parte superior que dice que se puede acceder navegando a /counter. En el componente, puede ver el código de marcado HTML y el código C#. La página en sí muestra el valor de un contador que se implementará cuando hagamos clic en el botón. Esto sucede sin el uso de JavaScript. El código que hará que esto funcione se incluye dentro del bloque @code y, de hecho, es código C#. Cada vez que hagamos clic en el botón, el valor del contador aumentará y, automáticamente, la interfaz de usuario mostrará el nuevo valor. Blazor hará esto comparando el contenido nuevo con el antiguo y aplicará los cambios al DOM de la página. En la mayoría de los casos, no es necesario pedirle a Blazor que realice esta verificación. Lo hará automáticamente. Esto significa que no necesita llamar a una actualización manualmente. Blazor notará los cambios y actualizará la interfaz de usuario cuando sea necesario, en la mayoría de los casos. Si coloca el código de la diapositiva anterior en un archivo llamado Counter.razor, ahora podemos usar el componente, como podemos ver aquí. Simplemente use el componente Contador soltando el elemento Contador en otro componente. Este es, de hecho, un Index.razor en el que ahora está anidado el contador. Dentro de la carpeta wwwroot, hay un HTML simple llamado index.html. Piense en lo que expliqué anteriormente, se compila una aplicación Blazor del lado del cliente y esos archivos se colocan como archivos estáticos en un servidor y se descargarán al cliente. Por supuesto, el usuario de su aplicación necesita navegar a una página web que aloja la aplicación. Esa página es este index.html, por lo que es una página HTML normal, y contendrá el código que activará el lanzamiento de su aplicación Blazor. Esto se hace mediante el uso de un archivo JavaScript integrado llamado blazor.webassembly. js. Ese es un archivo que se crea para nosotros. No se necesita ninguna acción real de nuestra parte para hacer esto.

Demostración: exploración de un nuevo proyecto Blazor WebAssembly

Muy bien, ahora regresemos a Visual Studio y creemos juntos una nueva aplicación Blazor WebAssembly. Una vez que la plantilla se haya ejecutado, exploraremos con más detalle los archivos recién creados. Muy bien, ahora vamos a crear nuestra primera aplicación Blazor y, por supuesto, será una aplicación WebAssembly. Y mientras hacemos eso, exploraremos los archivos generados, así como parte del código ya generado. Así que voy a ir aquí en Visual Studio, Crear un nuevo proyecto. Ya lo hicimos en el módulo anterior, pero hagámoslo de nuevo aquí. Así que buscaré blazor y, de hecho, seleccionaré Blazor WebAssembly y llamaré a mi aplicación BethanysPieShopHRM.App. Esta será nuevamente una aplicación WebAssembly, por lo que se ejecutará completamente en mi navegador. voy a seleccionar NET 6 ya que esa es la versión que estamos usando en este curso. Aquí no seleccionamos ninguna de las otras opciones. Pulsamos Crear para que Visual Studio vuelva a ejecutar esa plantilla, y eso crea, de nuevo, la aplicación que ya vimos en el módulo anterior. Ahora estoy ejecutando la aplicación nuevamente para mostrarles un poco aquí sobre los componentes. Son los que ves aquí. Cuando hago clic aquí en este botón Contador, de hecho cargaré un componente diferente, un componente de página, porque es básicamente un componente de relleno de pantalla. Hago clic en Obtener datos, que navegará nuevamente y ahora navegará a otro componente, de hecho nuevamente, un componente que está llenando la pantalla, y es por eso que lo llamo componente de página. Los componentes son, por supuesto, el bloque de creación de las aplicaciones Blazor. Antes de mirar los componentes, veamos qué constituye la aplicación, qué archivos se utilizan para crear la aplicación en ejecución. Entonces, hagámoslo mirando los archivos generados. Aquí, en el Explorador de soluciones, le mostraré primero el index.html, que se encuentra dentro de la carpeta wwwroot. Si está familiarizado con ASP.NET Core, esta carpeta, y en general la estructura de esta solución de este proyecto, le parecerá bastante familiar. De hecho, la carpeta wwwroot es la carpeta que contiene los activos estáticos de la aplicación, es decir, los archivos estáticos que se descargarán al cliente. Por ejemplo, imágenes, archivos CSS y archivos de configuración de aplicaciones. Pero veamos, por ahora, ese archivo index.html. De hecho, ese index.html es, diría, la página de alojamiento que alojará nuestra aplicación Blazor, y lo hará justo aquí. Como se puede ver, hay un div con una aplicación de identificación que inicialmente dice Cargando. Por supuesto, no hay código Blazor en esta página. De hecho, Blazor se cargará con la ayuda de JavaScript, y ese es el archivo, este archivo blazor.webassembly.js, que será responsable de cargar nuestra aplicación Blazor. No tenemos que hacer toda esa plomería. Microsoft ya se ocupa de eso mediante el uso de este archivo blazor.webassembly.js que se incluye en cada nuevo proyecto de Blazor. También puede ver aquí, en el encabezado de esta página circundante de esta página html de alojamiento, que también hacemos referencia a un par de hojas de estilo, por lo tanto, archivos CSS, y aquellos que también podemos usar en nuestra aplicación Blazor. Entonces, esta página se cargará cuando nuestra aplicación se solicite inicialmente, digamos. Y alojará, renderizará, nuestra aplicación Blazor. Ahora dije que este div es importante ya que especifica dónde se cargará nuestro componente App, nuestra aplicación. Ahora bien, ¿cómo evolucionan las cosas a partir de aquí? Bueno, es una aplicación Blazor, y esa es una aplicación ASP.NET Core, por lo que las cosas comienzan en Program.cs. Veamos primero ese archivo. Entonces, la clase Program, al igual que con cualquier aplicación ASP.NET Core, es el punto de partida de nuestra aplicación, es el punto de entrada, digamos. Y nuevamente, si conoce ASP.NET Core, este código le resultará bastante familiar. Primero, se crea WebAssemblyHostBuilder, y luego esta línea es bastante importante. Aquí estamos especificando cuál será el componente raíz de nuestra aplicación. El componente raíz será App y se cargará en un div con id app, y ese fue el que está aquí en index.html. Luego, esta línea aquí especifica que los servicios se agregan a la colección de servicios. Eso tiene que ver con la inyección de dependencia y, nuevamente, es muy similar a cómo se hace en ASP.NET Core "normal". Estamos usando, de hecho, la misma colección de Servicios. Veremos la inyección de dependencia y esa colección de servicios más adelante. Ahora, si desea seguir cómo se construyen las cosas, bueno, estamos especificando aquí que la aplicación debe ser el componente raíz, así que echemos un vistazo a la aplicación. La aplicación es un componente, el componente de la aplicación, y ese es un archivo Razor, como lo será cualquier componente. Ahora, aunque ya te explicaré esto, puede parecer un poco complejo. Veremos lo que está sucediendo en este archivo con mucho más detalle más adelante. Desde una perspectiva de alto nivel, lo que se está haciendo aquí es configurar el enrutamiento para la aplicación Blazor. Otro componente, el enrutador, se agrega en el componente de la aplicación. El Router es un componente que se encarga de interceptar la navegación, y en lugar de mostrar una nueva página, lo que normalmente hace un navegador, este se encargará de mostrar otro componente para que nos lleve a un componente diferente. Si se encuentra el componente solicitado, se le pasarán datos y el diseño también se utilizará para representar el componente solicitado. Ese MainLayout es el siguiente archivo que veremos. Vive en la carpeta Compartida. Si conoce ASP.NET Core MVC, por ejemplo, probablemente esté familiarizado con los archivos de diseño. Son, digamos, plantillas de página. Contienen el código que es idéntico para todas las páginas dentro de mi aplicación, excepto el cuerpo, y MainLayout es exactamente lo mismo. Es un componente, nuevamente, que contiene el código de diseño común, como NavMenu. Ese es el menú que teníamos a la izquierda. Luego también especifica el Cuerpo, y ahí es donde se renderizarán los componentes reales. El NavMenu es otro componente. Ese es el componente que contenía los enlaces que vimos a la izquierda, Inicio, Contador y Obtener datos. Como puede ver, todos estos contienen solo código HTML. Ahora, cuando cargamos la aplicación, vimos una página de destino. De hecho, también se estaba renderizando un componente para eso. En la carpeta Páginas vimos inicialmente el componente Índice. Esto es, de nuevo, un componente. Ahora he hecho referencia bastante a los componentes. Dije que AppRazor era un componente. Dije que MainLayout era un componente. Ahora bien, ¿qué es realmente un componente? Bueno, es una pieza de diseño que, combinada con la lógica, ejecutará una funcionalidad. Aquí está mostrando el índice, digamos la página de inicio. Y como podemos ver, contiene HTML. No hay C# en este. Es un componente muy simple, pero la mayoría de los componentes ofrecerán funcionalidad, y eso está escrito en C#. Ahora, este era el Razor indexado, y tenía en su parte superior la directiva @page que especificaba que si no especificamos otra URL, este índice se cargará. Es la raíz de la aplicación, y está cargada, este Index.razor es decir, dentro de MainLayout donde se especificó el @Body. Ahora bien, este es un componente muy simple. Veamos otro, el Counter.razor. Eso ya es un componente real. De nuevo, contiene @page "/counter". Así es como podemos llegar a este componente Counter. Podemos navegar hasta él especificando /counter. Y luego volvemos a tener algo de marcado. Voy a guiarlo a través de la funcionalidad con un poco más de detalle. Podemos ver aquí que tenemos un poco de código. Esa es la lógica que normalmente escribiría en una clase separada, pero más sobre eso más adelante. Por ahora, solo sepa que este es un código C#. Allí se definió una variable llamada currentCount, y quiero mostrar su valor aquí. Y puedo hacerlo especificando @currentCount. El símbolo @ es la sintaxis de Razor para especificar que viene el código. De hecho, el valor de currentCount debe representarse aquí. Entonces tenemos este botón aquí. Ese botón fue el botón en el que hicimos clic para aumentar el valor del contador, y ahí hemos definido un @onclick. @onclick es un controlador de eventos que activará el método IncrementCount. Se invocará el método IncrementCount, y eso aumentará el valor de currentCount. Sin tener que actualizar la interfaz de usuario, también se mostrará el nuevo valor de currentCount. Y FetchData, bueno, ese es otro componente que ya contiene un poco más de lógica como podemos ver aquí. Por supuesto, escribiremos bastantes componentes que contienen mucha más funcionalidad. Ahora quiero mostrarles una cosa más. Cuando quiero usar un componente, digamos que quiero usar el componente Contador en la página de índice, así que en la página de inicio, simplemente puedo hacerlo escribiendo Contador. Como pudimos ver, Visual Studio ya me da algo de inteligencia aquí. Y puedo colocar varios contadores en este componente de índice. Pongamos tres allí y ejecutemos la aplicación de nuevo. Y ahora realmente verá que los componentes son realmente islas de funcionalidad que puedo colocar dentro de otros componentes. Ahora tenemos, de nuevo, el índice, que es la raíz de la aplicación, y tengo varios componentes de contador colocados en este componente de índice. Hay un archivo más que no he mencionado, y son las Importaciones aquí, _Importaciones debería decir. En ese archivo, normalmente colocaré declaraciones de uso común para no tener que incluirlas dentro de mis otros componentes. Aquí vamos. Ahora ya tenemos una buena comprensión de cómo se construyen las aplicaciones Blazor. Y verá que esta estructura es seguida incluso por aplicaciones más complejas como la aplicación que construiremos en este curso. Usaremos Razor todo el tiempo al crear la interfaz de usuario de nuestros componentes. Razor es bastante simple, y creo que mientras sigue este curso, lo aprenderá con bastante facilidad. Sin embargo, dado que Razor es el mismo en todas las tecnologías de ASP.NET Core, también puede echar un vistazo a la ruta de ASP.NET Core para obtener más información sobre Razor. Le mostraré las reglas de sintaxis en cualquiera de las diapositivas aquí, así que solo quería aclarar eso antes de continuar.

Creación de una primera aplicación Blazor

Ahora que ha visto lo que se crea y comprende cuál es la función de los diferentes archivos, comencemos con la creación de nuestra primera aplicación. Una cosa más que quiero señalar aquí antes de que realmente comencemos a construir la aplicación. En el proyecto generado, habrá notado que el código para la funcionalidad de la aplicación se coloca dentro de un bloque @code. En este caso, el marcado y la funcionalidad se mezclan en un solo archivo. Ahora, mientras esto funciona, para aplicaciones más grandes, no creo que sea realmente el mejor enfoque. Sugiero usar un enfoque de código subyacente donde movemos nuestro código C# a una clase separada y eso es, de hecho, lo que vamos a hacer también en nuestra aplicación. Esa clase de código subyacente es entonces la clase de componente. De hecho, la clase que crearemos será una clase parcial, al igual que la clase generada en función del propio código del componente. Como referencia, aquí se ve el enfoque mixto. En el mismo archivo, ahora tiene el marcado y un bloque de código. Si bien esto no tiene nada de malo, no creo que, para una aplicación real, desee que todo su código esté en un solo archivo. Tratar de escribir pruebas unitarias para esto, como haremos más adelante, no funcionará fácilmente. Por lo tanto, abogo por mover su código a una clase separada. En este enfoque, nuestro código vivirá en un archivo separado que contiene una clase parcial. Los propios componentes de Razor se generan como clases parciales, lo que nos permite, como desarrolladores de Blazor, crear una clase parcial que se combinará con la clase del componente principal. Si estamos creando un componente llamado EmployeeOverview, simplemente podemos crear otra clase parcial con el mismo nombre, EmployeeOverview, como puede ver aquí, donde podemos agregar nuestro código. Me verás usando este enfoque la mayor parte del tiempo.

Demostración: Creando la Primera Página de Nuestra Aplicación

Tiempo para la acción. Ahora crearemos la primera página de nuestra aplicación, y eso también será un componente, por supuesto. Ahora hemos explorado lo que se genera de forma predeterminada, por lo que al ejecutar Archivo, Nuevo proyecto. Ahora es el momento de comenzar a construir nuestra aplicación, y lo primero que voy a hacer es deshacerme de algunos de los archivos que se generaron como parte de la ejecución de la plantilla. Voy a eliminar Counter.razor y también voy a eliminar FetchData. Lo dejaré en el componente Índice, y lo cambiaremos más adelante. Los otros archivos que voy a cambiar también, así que los dejaré también. Necesito ir al Programa, de hecho ya lo tengo abierto aquí, y también voy a borrar esta línea aquí que agrega un servicio a la colección de Servicios. Muy pronto agregaremos nuestros propios servicios. Ahora es el momento de comenzar a construir BethanysPieShopHRM. Bueno, y para ello, ya he preparado una serie de archivos para representar las entidades o las clases de dominio con las que vamos a trabajar. Si ingresa a los Activos que vienen con la descarga de este curso, encontrará en m3, es decir, este mismo módulo, la carpeta BethanysPieShoppeHRM.Shared que contiene el proyecto compartido que contiene las entidades a las que me refería. Copie esa carpeta y luego, de vuelta en Visual Studio, abra la carpeta que contiene su solución actual y pegue la carpeta allí. Luego, de vuelta en Visual Studio, agregue el proyecto compartido haciendo clic con el botón derecho en la solución y luego diciendo Agregar, Proyecto existente y navegue a la carpeta de la solución actual, luego seleccione Compartido y luego el archivo csproj. Eso agregará el proyecto Compartido a nuestra solución, y allí encontrará, de hecho, una carpeta de Dominio que contiene las entidades que usaremos en nuestra aplicación. Ahora vamos a trabajar con Empleados, por lo que, lógicamente, hay una clase de Empleado que contiene la definición de un empleado, que contiene un Id. de empleado, Nombre, Apellido, Fecha de nacimiento, Correo electrónico, Calle, etc. Puedes ver todas estas propiedades aquí. Observe que también tengo una propiedad Country, Country es otra clase. Contiene un CountryId y un Nombre. Lo mismo ocurre, por cierto, con la JobCategory que encontramos aquí. También es una clase separada. Y luego también tengo el Estado Civil y el Género. Ambos son una enumeración, como puedes ver aquí. Y finalmente, también tengo una Latitud y una Longitud, y esas también son propiedades anulables. Básicamente, en nuestra aplicación vamos a trabajar principalmente con esa clase de empleado y, por supuesto, también vamos a trabajar con las otras clases, pero principalmente vamos a trabajar con la clase de empleado. Vamos a tener que usar esto desde nuestra aplicación Bethany'sPieShopHRM, así que en la aplicación Blazor. Entonces, comenzaré agregando una Referencia del proyecto y seleccionaré aquí el proyecto Compartido. Ahí tienes Es hora de comenzar a compilar la aplicación Blazor y eso significa, por supuesto, compilar nuestro primer componente real. Esa va a ser la página de Resumen para todos los empleados. Así que voy a crear un nuevo componente, y de hecho va a ser un componente de página, un componente que llena toda la página, y ahí es cuando me refiero a ellos como un componente de página. Así que voy a hacer clic con el botón derecho aquí en Pages y diré Add, new Razor Component. Voy a crear la Descripción general del empleado como un componente de Razor. Entonces, el nombre es EmployeeOverview, haga clic en Agregar y luego se creará el archivo EmployeeOverview.Razor. Ahora se ha generado un código predeterminado. También verá que Visual Studio de forma predeterminada generará el bloque @code. No voy a usar eso. Voy a crear una clase separada. Entonces, de una vez, voy a crear la clase Componente como una clase regular y luego debo dar los mismos nombres para EmployeeOverview.Razor.cs. Y cuando haga lo de .Razor.cs, Visual Studio ordenará este archivo justo debajo del componente, o la interfaz de usuario del componente. E inmediatamente nos estamos poniendo rojos ondulados aquí, y eso se debe a que EmployeeOverview.Razor genera una clase, EmployeeOverview, que es una clase parcial. Así que ahora también he creado una clase con el mismo nombre, por lo que obtenemos un nombre ambiguo. Así que debo agregar aquí que esta será una clase parcial, y luego Visual Studio estará feliz nuevamente. Así que ahora tenemos una clase de Componente, este archivo aquí, y tenemos la interfaz de usuario, EmployeeOverview.razor. Volvamos aquí. Ya voy a eliminar lo que se ha generado aquí, y lo primero que voy a agregar aquí es la directiva de la página. Quiero poder navegar a este componente. Recuerde, era un componente de la página. Así que voy a decir aquí que esto se puede abordar navegando a /employeeoverview. Tenga en cuenta que, de hecho, no distingue entre mayúsculas y minúsculas. Aquí, ahora voy a crear una interfaz de usuario para mostrar la lista de todos los empleados. Ahora no tenemos ningún lugar que tenga a esos empleados establecidos, así que haremos eso primero. En este punto, trabajaré con datos simulados y reemplazaremos esos datos simulados en un módulo posterior con datos provenientes de una API. Así que los datos simulados que voy a crear, bueno, en una carpeta separada, voy a agregar aquí otra carpeta en mi proyecto. Voy a llamar a eso Modelos, y allí voy a crear la clase MockDataService. El código para MockDataService no tiene que escribirlo usted mismo. Te mostraré el resultado, pero puedes, de hecho, encontrarlo con los activos nuevamente. Vaya a la carpeta m3 nuevamente, y allí encontrará un archivo M3 Snippets que contiene los fragmentos que estoy usando en este curso también, y ese será el caso para los otros módulos también. Entonces, si me ves copiando mucho código, bueno, eche un vistazo al archivo Snippets del módulo correspondiente. Aquí está el código para MockDataService. He creado una List<Employees>, que es una lista estática, y he hecho lo mismo para las categorías de trabajo y los países. Y tengo una propiedad estática, Empleados, que de hecho configura todas estas listas si no se han inicializado. Y llamaremos a InitializeMockCountries y asignaremos el resultado a los países si no se ha inicializado. Hago lo mismo para JobCategories y para Employees y devuelvo _employees. Las categorías InitializeMockJobCategories, así como InitializeMockCountries, se pueden encontrar al final del archivo. Solo voy a devolver una nueva lista con datos codificados y que están haciendo ambos métodos. Y, de hecho, haré lo mismo con InitializeMockEmployees. Actualmente tengo dos empleados allí, y serán devueltos por este método. Así que ahora tenemos algunos datos simulados con los que podemos trabajar y, llegados a este punto, podemos centrarnos en la parte de Blazor. No tenemos que molestarnos en obtener datos de una API. Nuevamente, lo haremos más tarde. Así que ahora volvamos a nuestra EmployeeOverview. Y, de hecho, voy a ir a mi clase de Componente. Aquí, voy a crear una lista de empleados. Esa será la lista de empleados que quiero visualizar. Y necesito traer la declaración de uso correcta. Ahora, los componentes tienen un ciclo de vida. Hablaremos más sobre los métodos del ciclo de vida más adelante. Son métodos que se llaman en puntos específicos del ciclo de vida del componente, por ejemplo, en el momento de la creación del componente. Normalmente, no colocará código en el constructor de un componente. Por lo general, colocará código que, por ejemplo, obtenga datos de una API o, en nuestro caso, de un MockDataService en un método de ciclo de vida. Y el método que usaremos para configurar nuestro componente es OnInitialized, o su hermano, OnInitializedAsync. Así que vamos a anular OnInitialized, y dado que no tenemos ningún código asíncrono, podemos usar OnInitialized en este punto. Y aquí, voy a decir que los Empleados, por lo que esta Lista aquí, obtendrá sus datos del MockDataService. Ese es el que acabamos de crear. Ingrese la declaración de uso correcta y luego diga .Empleados. Esa era esa propiedad estática. Así que ahora nuestros datos ya están allí y estarán disponibles en esta propiedad pública, empleados. Ahora, en el componente de empleado, voy a escribir HTML. De hecho, debería decir que voy a escribir algo de código Razor. Vamos a entremezclar el HTML con las declaraciones de Razor utilizando la sintaxis de Razor. Ahora me verás haciendo eso todo el tiempo. Pero la mayor parte de esto será simplemente HTML. Comenzaremos con el título. Estoy agregando aquí un h2, diciendo que esta será la Descripción general del empleado. Ahora voy a representar a mis empleados en una tabla. Aquí hay una tabla HTML simple. Tengo un encabezado que dice que voy a mostrar la identificación, el nombre y el apellido. Y luego en el cuerpo voy a, bueno, digamos generar dinámicamente filas para cada empleado que tengo. Voy a escribir una declaración de Razor, y lo que voy a hacer es recorrer todos los empleados en esa lista de empleados aquí. Así que aquí voy a crear un bucle. Voy a usar un foreach. Voy a decir que foreach empleado en Empleados. Tenga en cuenta que Visual Studio IntelliSense sabe acerca de los empleados. Esa no es la misma clase, es una clase parcial. Y por cada empleado que encuentre, voy a generar una nueva fila. Ahora en cada fila voy a mostrar cuatro cosas. Permítanme comenzar mostrando la identificación del empleado. Necesito indicarle a Razor nuevamente que ahora viene el código, así que necesito usar otra instrucción @. Voy a quedarme aquí @employee, ese es este empleado aquí, muéstrame la identificación de empleado para ese. IntelliSense funciona aquí porque conoce a los empleados. Voy a hacer lo mismo con FirstName y LastName, así que déjame hacerlo rápidamente aquí. Y observe que, de hecho, en mi encabezado tenía definidas cuatro columnas. Voy a agregar otra columna aquí que muestra una imagen. Así que ahora agregué otro td que contiene una imagen y que contiene un enlace en el que puedo usar el código C#. Observe que estoy usando la interpolación de cadenas para concatenar una URL, una URL fija con {employee.EmployeeId}-small.jpg. Esas son algunas imágenes que tengo aquí en Azure en una cuenta de almacenamiento. Así que ahora esta fila se generará dinámicamente para todos los empleados dentro de esa lista de empleados. Ahora voy a rodear esto con una declaración if. Déjame hacer eso primero. Voy a decir que cuando Empleados sea nulo, mostraré esta cadena de carga. Podría ser que Empleados aún sea nulo, y luego voy a mostrar Cargando. No hemos utilizado un método asíncrono aquí, pero si los datos llegan de forma asíncrona, es decir, desde una API, entonces esto será realmente útil. Ahora, todavía no tenemos ningún código asíncrono, por lo que los empleados no serán nulos inicialmente, pero si nuestros datos se cargan de forma asíncrona desde una API, los empleados serán inicialmente nulos. Pero cuando ya no sea nulo, Blazor lo notará como una interfaz de usuario de actualización y ejecutará automáticamente el código del bloque else aquí, por lo que no tenemos que pedirle a Blazor que actualice la interfaz de usuario para esto. Creo que nuestro componente está listo. Veámoslo en acción. Y ahora necesito navegar a /EmployeeOverview. Y ahí vamos, hemos creado nuestro primer componente que muestra el empleado que teníamos en el MockDataService. Genial, aunque estoy un poco decepcionado. Todavía no se parece a lo que les mostré al principio, pero eso es algo de la interfaz de usuario. Todavía no hemos dedicado tiempo a cambiar la apariencia de nuestra aplicación.


Mejorar el diseño

Creo que estarás de acuerdo en que nuestra aplicación funciona. El efecto del primer componente funciona, pero no se parece a lo que te mostré al principio. Agreguemos un poco de código de diseño a continuación. Y sorpresa, sorpresa, eso también se logrará mediante el uso de componentes. En nuestra aplicación, y en la mayoría de las aplicaciones que creará, hay algunos elementos de las páginas que se mostrarán, bueno, en casi todas las páginas. Si observa una estructura típica, cosas como el encabezado, el menú y quizás el pie de página, se comparten quizás en todas las páginas y, por lo tanto, no cubriremos estos componentes en todas las páginas. Si necesitamos hacer un cambio, es posible que debamos actualizar cada componente de la página para reflejar estos cambios. Eso no es muy eficiente. En Blazor, podemos crear un diseño para este mismo propósito, que es en sí mismo, de nuevo, un componente que contendrá los componentes repetidos, como el menú. Otros componentes querrán usar este diseño y necesitarán hacer referencia a él. El diseño generalmente usará un marcador de posición donde luego se deberá mostrar el contenido principal de la página. Por lo tanto, los diseños son componentes que contendrán las partes de la interfaz de usuario que normalmente se comparten en varias páginas. Si conoce ASP.NET Core MVC, por ejemplo, estos diseños son muy similares al archivo _Layout.cshtml, que normalmente se encuentra en la carpeta compartida. En una aplicación, puede tener uno o más diseños. Las propias páginas que usan el diseño deben incluir una referencia al diseño que desean usar. Por lo general, también habrá un diseño predeterminado y veremos que se establece desde el archivo App.razor. Y, de hecho, al igual que en MVC, normalmente también en Blazor, estos componentes de diseño se comparten entre varios componentes y también se colocan en una carpeta compartida. Los diseños en sí mismos son, como se dijo, componentes, por lo que también tienen la extensión Razor y pueden contener código, nuevamente, preferiblemente en una clase de componente parcial. Sin embargo, los diseños tienen una clase base diferente a la de los componentes normales. Todos heredan de la clase LayoutComponentBase, mientras que los componentes regulares heredan de ComponentBase. Esta clase base traerá una propiedad Body, que es el marcador de posición donde debe ir el contenido. Aquí puede ver el diseño que se generó como parte de la nueva plantilla de proyecto. Nos muestra lo suficiente para trabajar aquí. Este diseño es un componente, pero observe en la parte superior, ahora tenemos @inherits LayoutComponentBase. @Inherits es código Razor para definir la clase base, de hecho, tiene el prefijo @. El diseño contiene el código que se repetirá en todos los componentes que hacen referencia a este diseño y que, por ejemplo, incluye NavMenu. Por lo general, se incluye un menú en el diseño y luego se comparte entre las páginas que usan este diseño. Luego, donde se coloca @Body, se incluirá el contenido creado por el componente real que hace referencia a este diseño. Eso es simplemente el marcador de posición. Si ahora un componente, generalmente un componente de página, quiere hacer referencia a este diseño, puede hacerlo usando @layout y luego el nombre del componente de diseño. Es muy común que la mayoría de las páginas, si no todas, usen el mismo diseño y, por lo tanto, incluir @layout en cada página puede ser un poco complicado. Por lo tanto, es posible definir un diseño, que luego se utiliza para toda la aplicación. Y eso se hace en la App.razor, como podemos ver aquí. Veremos con más detalle App.razor, pero App.razor es el componente de la aplicación y también contiene alguna configuración. Contiene el componente de enrutador, que es responsable de enrutar a los componentes de la página. Y allí, podemos ver que se especifica DefaultLayout. Esto es realmente un valor predeterminado. Los componentes de la página aún pueden definir otro diseño si así lo desean, por lo que pueden anularlo fácilmente.

Demostración: Mejora del diseño

Volvamos a Visual Studio y traigamos un diseño y otras mejoras de la interfaz de usuario para que nuestra aplicación se vea mucho mejor. En este punto, nuestra réplica, bueno, no se parece a lo que les mostré al principio, pero lo arreglaremos. Ahora, para cambiar la interfaz de usuario, vamos a usar en las aplicaciones Blazor, las herramientas y los lenguajes que usamos, bueno, en cualquier aplicación web. Después de todo, es solo una aplicación web, ¿verdad? Entonces, si miras, por ejemplo, en wwwroot, hay una carpeta css que ya contiene una versión minificada de Bootstrap, la famosa biblioteca CSS. De hecho, se incluye una versión reducida de Bootstrap 5.1 con la plantilla en el momento de la creación de este curso. Ahora, también necesito los archivos de JavaScript que vienen con Bootstrap para que mi interfaz de usuario funcione como debería. Así que no voy a usar este, De hecho, traeré la última versión en el momento de la creación de este curso. Así que voy a hacer clic derecho aquí en mi proyecto y decir Agregar, Biblioteca del lado del cliente. Eso abre Library Manager, o para abreviar, LibMan, y luego me permite trabajar con bibliotecas del lado del cliente y descargarlas de un proveedor. Voy a decir aquí que quiero Bootstrap 5.2, esa es la versión que probé con este curso, y la voy a descargar en esta misma ubicación aquí. Asegúrese de usar también esta ubicación si desea que las cosas funcionen correctamente. Y luego hago clic en Instalar, y después de unos segundos, verá la carpeta lib que aparece aquí, y que ahora contiene una carpeta Bootstrap, y contiene, nuevamente, Bootstrap CSS, pero también el JavaScript que necesitaré. Ahora, mientras estamos aquí, también veremos que hay una aplicación. css que contiene el CSS que Microsoft usa de forma predeterminada para esa plantilla predeterminada. No lo voy a usar, voy a pegar, bueno, diré, una versión personalizada de Bootstrap, que incluye colores y también algunas cosas personalizadas, que puede encontrar nuevamente en los activos. Entonces, en los activos, encontrará que hice app.css, cópielo en la carpeta css, confirme que desea anular el ya existente, y ahora tiene el CSS correcto para nuestra aplicación. Ahora, mientras estamos en eso, también copie la carpeta de imágenes en esta carpeta wwwroot, que es después de todo, la carpeta de archivos estáticos y ese es el lugar donde deben ir los archivos estáticos. Asegúrese de no copiar esto en la raíz de la aplicación, ya que entonces sus imágenes simplemente no se encontrarán. Ahora vamos a cambiar el diseño de nuestra aplicación, y volvamos a algo que ya os expliqué en el módulo anterior, la App.razor. App.razor era el componente de la aplicación que contenía el enrutador, y allí hay un RouteView que también especifica un diseño predeterminado. En otras palabras, lo que está sucediendo aquí es que si enrutamos a una página determinada, se aplicará un diseño por defecto a menos que la página defina su propio diseño. Ahora, aquí hemos definido que el diseño predeterminado es el diseño principal y, de hecho, no voy a comenzar a anular los diseños en este curso, por lo que siempre confiaremos en ese diseño principal para que sea el diseño de todas las páginas. para todos los componentes de la página, debería decir, en mi aplicación. Ese diseño principal vive aquí en la carpeta Compartida. Ya vimos ese, que era, nuevamente, código HTML que contiene otro componente, el NavMenu a la izquierda, así que para la barra lateral, y luego el cuerpo, que es el marcador de posición, bueno, para el componente principal. Voy a anular esto bastante con, nuevamente, el código que puede encontrar en el fragmento. Aquí está el código actualizado. Tengo bastante código de interfaz de usuario que contiene un logotipo, un botón que muestra el menú colapsado si no tenemos suficiente espacio en la pantalla, y tenemos otro div si contiene los nombres, así que Bethany's Pie Shop HRM, un algunos marcadores de posición, pondremos algunas cosas allí más adelante, y luego tengo este div que contiene el NavMenu, así como el marcador de posición Body. Entonces, una interfaz de usuario completamente actualizada, que también contiene un diseño receptivo basado en Bootstrap. No me voy a molestar en explicarte todo el código aquí, esto es solo código de Bootstrap para construir una página receptiva. Ahora, lo importante es que NavMenu, ese es el menú de la izquierda, También voy a incluir una nueva versión, nuevamente, un fragmento. Vayamos a NavMenu. Ya hay bastante código creado por la plantilla, voy a reemplazar este código también con mi propio menú. Esta vez hay mucho menos código de lo que solía haber, solo tengo un enlace de Inicio y un enlace de Empleados en este punto. Aquí, estamos usando NavLink, que genera un enlace, digamos un botón, que mostraremos en nuestro menú. Así que ahora nuestro diseño se recogerá automáticamente porque está en App.razor, y luego hemos usado una versión actualizada de NavMenu. ¿Ya están bien las cosas? Bueno, casi. Necesito volver a mi index.html por ahora. En ese index.html, observe que estaba la antigua referencia de Bootstrap. Voy a borrarlo, ya no lo necesito. Hay una referencia a app.css, de hecho, ese es mi código CSS, y contiene Bootstrap completo, incluidas algunas cosas personalizadas, así que eso es lo que necesito. Pero necesito agregar algunas otras cosas aquí, voy a usar fontawesome para algunos íconos, y también voy a usar las fuentes de Google, así que también introduzco eso en el encabezado de mi página index.html circundante. Para fines de diseño, también voy a anular este div de carga aquí, que de hecho es el div de la aplicación que contiene la aplicación completa, y voy a agregar otra clase CSS allí, una clase Bootstrap, h-100, para que mi aplicación esté en pantalla completa. Ahora les dije al principio que necesitaba traer bootstrap.js, permitiéndome crear ese menú expandible o colapsable, así que también necesito traer una referencia de secuencia de comandos para ese archivo boostrap.js, y eso es lo que estoy haciendo. aquí, Estoy trayendo este bootstrap.bundle.js, que está dentro de la carpeta JS. Ya casi llegamos, creo. Ahora sí quiero cambiar mi index.razor en este punto porque esa será la página de destino que aún contiene ese contador aquí, por lo que en realidad olvidamos eliminarlo. Así que voy a eliminar todo el código aquí y reemplazarlo con lo siguiente. Solo voy a usar un h1 que dice Bienvenido a Bethany's Pie Shop, y un h3 que contiene un pequeño texto de bienvenida. Creo que estamos bien, creo que nuestra aplicación, si he hecho todo correctamente, ahora se verá mucho mejor. Probémoslo. Aquí vamos. Nuestra aplicación utiliza el esquema de color y el diseño que le mostré anteriormente. Podemos hacer clic en Empleados aquí, de hecho ya, y nos lleva a la Vista general de empleados. Perfecto.

Demostración: Depuración de aplicaciones Blazor

En la última parte de este módulo, veremos algunos detalles sobre la depuración de aplicaciones Blazor, y eso lo haremos en una demostración. Volvamos una vez más a Visual Studio para obtener más información. Depurar nuestra aplicación Blazor, bueno, es realmente simple. Y si está acostumbrado a depurar su Visual Studio, entonces el proceso es más o menos el mismo. De hecho, podemos poner puntos de interrupción en nuestro código y mirar nuestras variables, Relojes, la ventana Locales, como estamos acostumbrados con otras tecnologías .NET. Permítanme poner un punto de interrupción, por ejemplo, aquí en EmployeeOverview, y volveremos a ejecutar nuestra aplicación. He colocado un punto de interrupción en OnInitialized of Employees. Entonces, cuando haga clic allí, se alcanzará ese punto de interrupción. Verá, de hecho, este es un método de ciclo de vida que se ejecuta cuando se inicializa el componente. Ahora, en este punto, puedo hacer, por ejemplo, una ejecución al cursor, y ahora puedo explorar Empleados. Ves que hay dos empleados allí. Puedo mirar la ventana Automático, que también contiene Empleados y también me brinda una descripción general de EmployeeOverview, por lo que el componente en sí, y también me muestra algunas propiedades de los componentes de EmployeeOverview. También puedo mirar la ventana Locales. Eso contendrá solo esto en este punto, y también puedo crear Relojes. Ya creé una Vigilancia para Empleados, y eso nuevamente me da la capacidad de profundizar en los Elementos de esta lista de Empleados. Las opciones como Entrar, Pasar por encima y Salir también funcionan bien en Blazor. Entonces, la experiencia de depuración que obtenemos con Visual Studio es prácticamente la misma que obtenemos con todas las tecnologías .NET. Damos clic en continuar,

Resumen

Tenemos nuestra primera aplicación Blazor en funcionamiento. ¡Hurra! Y hemos comenzado a aprender acerca de los componentes. Creo que ya está claro que los componentes son muy importantes. Casi todo en Blazor es un componente. Crearemos bastantes componentes, y estos estarán anidados todo el tiempo. Los componentes también son una unidad de reutilización. Incluso podemos empaquetar componentes para utilizarlos en otras aplicaciones. Finalmente, hemos visto un conjunto especial de componentes, los diseños. Estos se utilizan para extraer el código de diseño a un componente separado y así mejorar la consistencia de nuestra aplicación. Ya hemos aprendido bastante sobre los componentes, pero hay mucho más por aprender. También ampliaremos nuestro conocimiento sobre los componentes en el próximo módulo. Te veo allí.