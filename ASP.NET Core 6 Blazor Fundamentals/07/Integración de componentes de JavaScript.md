# Integración de componentes de JavaScript

Cátedra Programación de Software y Programática - Fundamentos de ASP.NET Core 6 Blazor

**Introducción al módulo**

Blazor puede hacer muchas cosas geniales, y todo gracias a .NET. Pero a veces, necesitaremos ampliar nuestra aplicación con características de JavaScript, a las que no tenemos acceso nativo desde Blazor. De hecho, ya lo hicimos antes con el complemento LocalStorage que usamos para almacenar datos de manera persistente. Bueno, lo que hizo ese paquete, la interoperabilidad con JavaScript, aprenderemos cómo hacerlo en este módulo. Y de manera similar, también moveremos nuestro código a una biblioteca externa que también podemos usar desde otras aplicaciones. Suena bien. Profundicemos. En la primera parte de este módulo, aprenderemos sobre la interoperabilidad entre .NET Blazor y JavaScript. Nos centraremos principalmente en cómo podemos invocar código JavaScript desde nuestro código Blazor. Primero escribiremos el código en la aplicación, pero como verá, podríamos reutilizar fácilmente este código desde otra aplicación. Es por eso que en el segundo tema, moveremos nuestro código a una llamada biblioteca de clases de Razor. Y en la parte final, optimizaremos las cosas para que la biblioteca solo se cargue cuando realmente se necesite, y usaremos para eso una característica llamada carga diferida.

**Invocación de JavaScript desde Blazor**

Entonces, comencemos aprendiendo por qué necesitaríamos llamar a la ayuda de JavaScript en una aplicación Blazor y también cómo podemos hacerlo entonces. Creo que es fácil de entender que, aunque podemos crear experiencias ricas en Blazor, al final, son solo aplicaciones web. Con Blazor WebAssembly, podemos ejecutar la aplicación directamente en el navegador como una aplicación de una sola página que se podría compilar con Angular o React. No importa cómo lo mires, sigue siendo una aplicación web, pero escrita con HTML, pero respaldada por C# en lugar de JavaScript. Pero dado que nada más que una aplicación web se ejecuta de forma nativa en el navegador, también significa que JavaScript también funcionará bien en esa aplicación. Aunque ya podemos crear cosas realmente buenas con Blazor, su API no puede hacer todo lo que actualmente es posible con JavaScript. Hay bastantes cosas que son posibles en la aplicación basada en navegador para las que no hay una API de Blazor, al menos no todavía. ¿Significa esto que estamos atascados? Bueno, la buena noticia es que no, no estamos atascados. Blazor viene con la capacidad de interoperabilidad de JavaScript. Y como su nombre lo dice, nos permitirá desde el código C# invocar funciones de JavaScript. Entonces, si ya ha escrito una biblioteca de JavaScript existente, simplemente puede agregarla a la aplicación e invocarla desde su aplicación Blazor. Del mismo modo, puede interactuar con las API nativas de JavaScript, como LocalStorage desde una aplicación Blazor. Eso es lo que hizo el complemento LocalStorage, pero envolvió este comportamiento. Lo que necesita es algo de JavaScript que luego puede invocar y llamar desde la aplicación Blazor. Eso es todo. Esto, por supuesto, amplía bastante el alcance de una aplicación Blazor y se asegurará de que no haya un escenario que pueda realizar con Blazor. Tenga en cuenta que todo esto sucede en el navegador, por lo que el JavaScript real también se ejecuta en la máquina cliente. El código de Blazor interactuará con él. El código JavaScript será cargado por la página circundante, ya sea la página HTML o el host.cshtml en nuestra configuración. Cuando hablamos de la interoperabilidad de JavaScript en Blazor, lo más frecuente es que hablemos de la dirección de JavaScript de las llamadas .NET. Desde el código de Blazor, podemos invocar el código de JavaScript que está cargado y que luego puede realizar tareas que no son posibles de forma nativa desde Blazor. Pero, de hecho, la otra forma también funciona, por lo que JavaScript invoca .NET al código Blazor. En ese enfoque, lo que tenemos es que quizás un componente de JavaScript en la página circundante active una acción en Blazor. En aras de la simplicidad en este curso, nos centraremos en el primer tipo de interoperabilidad, pero es bueno saber que la otra dirección también funciona. Muy bien, veamos cómo podemos hacer que esta interoperabilidad funcione. Como ya lo hemos hecho varias veces en este curso, comencemos enumerando los pasos para hacer que las cosas hagan clic. Ya mencioné que habrá una llamada de nuestro código Blazor al código JavaScript, por lo que debe haber una secuencia de comandos cargada en el navegador. Eso lo haremos desde la página circundante así que el index.html o el host.cshtml. De hecho, si tiene varios scripts que necesitaremos llamar, todos estos deberán cargarse en la página circundante. Luego, para interactuar con JavaScript, Blazor viene con IJSRuntime. Esta interfaz se incluye en Blazor de forma predeterminada, pero para trabajar con una instancia de la misma, tendremos que volver a pasar por la inyección de dependencia. Si desea obtener acceso a una instancia de IJSRuntime, necesitaremos usar el atributo Inject nuevamente, lo que le indica a Blazor que queremos que se inyecte una instancia aquí. Una vez que tengamos eso, ahora podemos invocar una función en el script desde nuestro código Blazor. La función de JavaScript que queremos invocar debe estar disponible desde la aplicación Blazor. Podemos optar por incluir el script en la carpeta wwwroot y hacer referencia al archivo desde la página circundante. Alternativamente, también podemos colocar el script en línea. Aquí puede ver en el objeto de la ventana, he definido una función llamada DoSomething. Ese será el código del script. La función, querré invocar. A continuación, debemos inyectar el componente desde donde queremos invocar el código JavaScript, el IJSRuntime. Eso ya está presente en la colección de servicios, por lo que el contenedor DI. No necesitamos registrar ningún servicio adicional nosotros mismos. Luego, en el código del componente, una vez que tenemos la instancia a través de DI, podemos usarla para invocar la función de JavaScript. Eso es lo que ves que sucede aquí. En la instancia de IJSRuntime, ahora estoy llamando a InvokeAsync, pasando el nombre de la función que queremos invocar. En la función de JavaScript en sí, podemos exponer cualquier funcionalidad de JavaScript que queramos y, por lo tanto, invocarla a través de nuestro código Blazor. IJSRuntime ofrece dos métodos que podemos usar en este contexto. El InvokeVoidAsync generalmente se usa cuando estamos haciendo más un fuego y nos olvidamos de JavaScript, hacia una función de JavaScript que estamos invocando. es nula No esperamos nada de JavaScript. Si acaso, esperamos que algo regrese, usaremos el método InvokeAsync. Una nota importante aquí. ¿Cuándo podemos trabajar con la interoperabilidad de JavaScript en el ciclo de vida de un componente? En la demostración, veremos la interoperabilidad de JavaScript donde el código de JavaScript interactúa con el componente de la interfaz de usuario de Blazor. Para que esto funcione correctamente, debemos asegurarnos de que el componente Blazor se haya cargado correctamente. Y para eso, tenemos el método OnAfterRenderAsync, un método que forma parte del ciclo de vida del componente. De hecho, ese es el punto correcto donde debemos colocar este código. debemos asegurarnos de que el componente Blazor se haya cargado correctamente. Y para eso, tenemos el método OnAfterRenderAsync, un método que forma parte del ciclo de vida del componente. De hecho, ese es el punto correcto donde debemos colocar este código. debemos asegurarnos de que el componente Blazor se haya cargado correctamente. Y para eso, tenemos el método OnAfterRenderAsync, un método que forma parte del ciclo de vida del componente. De hecho, ese es el punto correcto donde debemos colocar este código.

**Demostración: creación de un componente de mapa**

Es hora de la primera demostración en este módulo. Vamos a agregar un mapa representado por JavaScript en la página Detalles del empleado, mostrando sus coordenadas en el mapa. Para cada empleado, podemos ver los detalles completos. Podemos hacer clic aquí en Detalles completos, y allí vemos la página con todos los detalles de un empleado. También tenemos en el tipo Empleado una latitud y longitud, y que voy a usar para mostrar en esta página de detalles, también un mapa que muestra dónde vive el empleado. Pero para mostrar ese mapa, voy a usar la interoperabilidad de JavaScript. Voy a usar de nuestro código Blazor, un componente de JavaScript que obtendrá sus datos de mi aplicación Blazor. Veamos cómo podemos hacer eso. Comencemos por crear el componente Mapa; eso va a ser un componente regular. Así que voy a empezar por crear un nuevo componente de Razor, y creo que un buen nombre para eso es Mapa. Para dibujar el mapa, voy a usar JavaScript. El componente, el componente JavaScript, de hecho, que voy a usar, requiere que usemos un div y luego el código JavaScript representará el mapa. Así que voy a empezar haciendo exactamente eso. La interfaz de usuario de este componente, de hecho, no será más que un div, y luego el código JavaScript representará el mapa en este div. Verá que todavía tengo un ondulado rojo porque quiero darle un nombre aleatorio. Lo haré en solo un segundo en la clase Componente. En este mapa, mostraré un marcador. Podemos añadir uno o más marcadores. En nuestro caso, solo agregaré uno, que apunta a la latitud y la longitud en nuestra clase Empleado. Voy a envolver ese marcador en una clase. Voy a usar para eso una clase separada que puse en mi proyecto Compartido. Ahora no quiero poner un marcador en mi carpeta de Dominio. El marcador realmente no es una entidad de dominio que voy a almacenar. Por lo tanto, voy a crear otra carpeta aquí. Será la carpeta Model, y allí crearé la clase Marker. Las propiedades de esta clase Marker se utilizarán para crear un marcador. Podemos ingresar una descripción y las coordenadas X e Y, por lo que la latitud y la longitud, y también podemos pasar un valor booleano para decir si queremos mostrar una ventana emergente cuando pase el mouse sobre ella. Ahora regrese a la clase Componente del mapa. En esa clase de mapa, voy a crear un elementId que resuelva este ondulado rojo aquí, y voy a establecerlo en una cadena aleatoria. Luego, también paso dos parámetros a este componente Map, un nivel de zoom, así como la lista de marcadores. Traigamos la declaración de uso correcta para esa clase de Marcador. Hasta ahora, hemos escrito algo de código C#, algunas propiedades en nuestro componente. Ahora voy a traer el código JavaScript que representará el mapa real y luego llamará desde Blazor. En la carpeta Activos para M7, por lo que este módulo, encontrará una carpeta y un archivo JavaScript. Copie todo esto en la carpeta wwwroot del proyecto Blazor, es decir. Echemos un vistazo a lo que realmente hemos agregado. El más importante para nosotros en este momento es este deliveryMap.js. Eso contendrá el código para representar el mapa. Aquí puede ver que estamos creando una función showOrUpdate que requiere un elementId, que será el id del div y una lista de marcadores. Así que esta será la función de JavaScript que llamará desde Blazor. No voy a mostrarte todo el código JavaScript. Este código JavaScript puro que dibujará el mapa. Entonces, para nosotros, debemos llamar a este showOrUpdate desde Blazor, así que volvamos a nuestro componente Map y, como se dijo en las diapositivas, cuando queremos trabajar con JavaScript, necesitamos trabajar con el tiempo de ejecución de IGS. Podemos inyectar un tiempo de ejecución de IGS, tal como lo hemos hecho antes. No necesitamos traer ningún servicio adicional manualmente. Entonces, en la clase Programa, Blazor lo conoce automáticamente. Entonces, con ese tiempo de ejecución de IGS, ahora podemos invocar nuestra función de JavaScript. Es importante realizar toda la interoperabilidad de JavaScript después de que se haya renderizado el componente. Por esa misma razón, tenemos un OnAfterRender y un OnAfterRenderAsync. En ese momento, el componente en sí se ha renderizado, los elementos HTML están ahí, y luego nuestro código JavaScript puede funcionar con los elementos representados por el componente. Así que voy a usar OnAfterRenderAsync. Primero hagámoslo asíncrono. Y ahora aquí, vamos a llamar a JSRuntime.InvokeVoidAsync. Esto va a ser un incendio y olvido. Vamos a llamar a deliveryMap.showOrUpdate. Fue esta función aquí. No esperamos ningún resultado, por lo que podemos usar InvokeVoidAsync. También estamos pasando el elementId que era esa cadena generada aleatoriamente, así como la lista de marcadores. Entonces, una vez hecho esto, ahora se invoca la funcionalidad de JavaScript, lo veremos renderizado en un momento, pero por supuesto, nuestro archivo JavaScript, por lo tanto, deliveryMap.js, así como en otros archivos necesarios para renderizar el mapa, como CSS , debe incluirse. Así que voy a ir a mi index. html y haga referencia a los de la página circundante, es decir, en nuestro caso, el index.html. Voy a traer un archivo CSS que está incluido en esa carpeta del folleto, este aquí, y por supuesto, traeré el archivo deliveryMap.js, y también traeré un folleto de apoyo, que también está en ese folleto. carpeta. En este punto, nuestro componente está listo, ahora podemos usarlo. Y vayamos ahora a nuestro componente EmployeeDetail. Y aquí abajo, en este div, simplemente renderizaré mi componente. Primero hagamos una compilación para que Visual Studio recoja el componente Map, y ahora podemos usar el componente Map. Aquí vamos. Encontraremos que tenía un parámetro Zoom. Estableceremos el Zoom en 10, y también pasaremos Marcadores. Agregaremos una lista de marcadores en solo un segundo. Voy a llamar a eso MapMarkers. El componente EmployeeDetail todavía no lo sabe, así que lo crearé aquí como una lista de marcadores, y obtendré esa lista de marcadores; va a ser una lista de un solo elemento como máximo. Usando el siguiente código, voy a verificar si la latitud y la longitud tienen un valor, y si ese es el caso, voy a agregar un nuevo marcador a la lista con estos valores. Está bien, vamos a probarlo. Hagamos clic en Empleados, haga clic en Detalles completos y listo. El mapa muestra el uso de latitud y longitud para este empleado. Sin embargo, puede ser que los archivos JavaScript no se carguen la primera vez. Asegúrese de hacer una actualización completa en su navegador para que los archivos se carguen correctamente. Como se mencionó, estamos usando en la demostración un componente que proviene de un proyecto de código abierto creado por Microsoft, y lo hemos usado aquí. Puede encontrar la fuente original de este componente en el enlace que ve en las diapositivas.

**Envoltura de componentes en una biblioteca de clases de Razor**

En este punto, nuestro componente Blazor habilitado para JavaScript se encuentra en el proyecto principal normal, por lo que es posible que este componente también sea útil en otra aplicación. Tal vez desee distribuirlo dentro de su empresa para otros proyectos, o incluso puede querer publicarlo por separado. En ese caso, necesitaremos envolver uno o incluso más componentes en una biblioteca de clases de Razor. Veamos cómo vamos a abordar esto. Necesitamos crear una biblioteca de clases de Razor, que es un tipo específico de biblioteca que también contiene componentes de Razor para usar dentro de otro proyecto que hace referencia a la biblioteca. Para crear una biblioteca de clases de Razor, Visual Studio ya viene con una plantilla para comenzar. Como se dijo, una biblioteca de clases de Razor es un tipo de biblioteca específico que puede contener componentes y los activos estáticos que requieren. Digamos que su componente también usará un archivo estático como un archivo CSS o un archivo JavaScript. Estos también deben incluirse dentro de la biblioteca de clases de Razor. Por supuesto, una biblioteca de clases de Razor puede contener más de un solo componente. Ahora, una vez que tenemos nuestros componentes en la biblioteca de clases de Razor, se pueden reutilizar entre proyectos e incluso podemos crear un paquete NuGet a partir de la biblioteca de clases de Razor para facilitar la distribución. Personalmente, recomendaría colocar solo componentes que tengan sentido para compartir entre proyectos en dicha biblioteca. No tiene mucho sentido mover todos los componentes que solo se usan dentro del proyecto principal a una biblioteca de clases de Razor. Por supuesto, será necesario hacer referencia a la biblioteca de clases de Razor desde el proyecto principal. Además de agregar una referencia del proyecto principal a una biblioteca de clases de Razor, si usamos el componente, necesitamos agregar una declaración de uso donde la estamos usando. Podemos agregarlo directamente en el archivo en el componente, pero si el componente se usa nuevamente en varios otros componentes, podría ser mejor agregar una declaración de uso en las importaciones nuevamente. Espero que recuerde que hacer esto hace que el espacio de nombres esté disponible en toda la aplicación. Por supuesto, también es posible utilizar el espacio de nombres completo. A continuación, para incorporar los activos estáticos, si se utilizan en los componentes de la biblioteca de clases de Razor, también debemos realizar un cambio en la página de alojamiento, por lo que host.cshtml o index.html. Y eso necesita tener una sintaxis particular, como puedes ver aquí. Entonces, comience con _content, luego el nombre del ensamblado y luego la ruta al archivo. De hecho, los activos estáticos deben colocarse en la carpeta wwwroot, nuevamente, también dentro de la biblioteca de clases de Razor.

**Demostración: creación de una biblioteca de clases de Razor**

Muy bien, es hora de una demostración. Lo que vamos a hacer es una pequeña refactorización. Voy a mover algunas cosas. Crearé una nueva biblioteca de clases de Razor y moveré el componente Mapa allí. Luego, también tendremos que hacer un cambio en el proyecto principal que ahora necesita cambiar algunas cosas para que el componente Mapa funcione como antes. Ahora voy a mover ese componente Mapa, así como los activos que agregamos, por lo que el CSS y el JavaScript, a una biblioteca de clases de Razor separada. Comencemos agregando una biblioteca de clases Razor a nuestra solución primero. Así que voy a hacer clic con el botón derecho en la solución, decir Nuevo proyecto y luego seleccionar Biblioteca de clases de Razor. Voy a llamarlo BethanysPieShopHRM.ComponentsLibrary. Aquí hay un proyecto generado, y bastantes cosas se generan de forma predeterminada. Echémoslos. Realmente no los necesitamos. Voy a eliminar el contenido de la carpeta wwwroot y también voy a eliminar Component1.Razor, así como ExampleJSInterop. En esta biblioteca de clases de Razor, podemos poner componentes, así como archivos estáticos. Y dado que nuestro componente de mapa es un componente general, y es posible que podamos usarlo en varios proyectos, tiene sentido moverlo a una biblioteca de componentes. Entonces, hagamos eso. Voy a desplazarme aquí, y voy a cortar el componente Mapa y la clase Componente, por supuesto, y pegarlo aquí en la biblioteca Componentes. Ahí está el Mapa, y también se elimina de la carpeta Componentes, eso es bueno. Voy a hacer lo mismo con el mapa de entrega y la carpeta del folleto, y lo pegaré aquí dentro de la carpeta wwwroot. Y si miramos hacia atrás en el componente Map, se quejará de que todavía necesitamos una referencia a la clase Marker. No sabe nada de eso, por lo que necesitaremos agregar una referencia de proyecto aquí al proyecto compartido. Aquí vamos. No estoy muy contento con el espacio de nombres aquí, así que voy a cambiar el espacio de nombres para que coincida con la estructura de carpetas, y luego se convierte en BethanysPieShopHRM.ComponentsLibrary, que ahora es el espacio de nombres. Asegurémonos de que esto ya se haya compilado, así que construyamos la biblioteca de componentes Muy bien, eso es bueno. Ahora podemos volver a nuestro proyecto Blazor y agregar una referencia de proyecto. Voy a hacer referencia a la biblioteca de componentes, y nuestro componente, nuestro componente de mapa, ahora vive en un espacio de nombres diferente. Así que eso es lo primero que arreglaré. Voy a ir a mi archivo de Importaciones, y voy a traer un uso aquí para BethanysPieShopHRP.ComponentsLibrary. Ahora, todos los componentes, en nuestro caso solo el componente Mapa, están disponibles desde nuestra aplicación Blazor. Ahora recuerde que en la demostración anterior, también hicimos un cambio en index.html. Allí, hicimos referencia a leaflet.css, deliveryMap.js y leaflet.js. Cuando usamos activos estáticos de un proyecto separado, por lo tanto, de una biblioteca de componentes en nuestro caso, debe usar una notación diferente. Primero cambiemos el enlace al archivo CSS aquí. Por lo tanto, siempre debemos usar este tipo de notación aquí, _content, luego el ensamblaje y luego el nombre del archivo, incluida quizás la carpeta. Haré lo mismo para estos dos archivos de script aquí. También usarán este tipo de notación. Creo que estamos bien. Hagamos una construcción. Está bien, y ahora ejecutemos la aplicación y hagamos una actualización completa para asegurarnos de que se descargan los archivos correctos. Muy bien, haz una actualización completa en el navegador. Ahora naveguemos de nuevo a Empleados, Detalles completos de Bethany, y nuestro componente de mapa aún funciona, pero ahora está dentro de un proyecto separado que luego podemos reutilizar en muchos otros proyectos.

**Carga de bibliotecas a pedido**

En la última parte de este módulo, aprenderemos sobre la carga diferida de bibliotecas como la que hemos creado en la parte anterior. De forma predeterminada, nuestra aplicación y cualquier otra biblioteca, como la biblioteca de clases de Razor que creamos como un ensamblaje independiente en la demostración anterior, se descargan cuando se inicia la aplicación. Entonces, para nosotros, eso significa que se descargan la DLL de la aplicación principal, así como la DLL de la biblioteca de clases de Razor. Blazor toma la ruta segura aquí. Aunque es posible que no necesitemos los componentes de la biblioteca inicialmente, o incluso en absoluto, todo se descarga al cliente y, en muchos casos, eso es lo mejor. Si desea que su aplicación se ejecute, quizás, sin una conexión activa, esta también es la única opción. Pero Blazor viene con una opción llamada carga diferida, donde podemos tomar el control, indicar a Blazor que posponga la descarga de un ensamblado hasta que nosotros lo indiquemos. En nuestra aplicación, podríamos decir que la biblioteca de clases de Razor que contiene el componente de mapa solo se necesita cuando el usuario navega a la pantalla de detalles por primera vez. Usando la carga diferida, eso es exactamente lo que podemos hacer. Podemos indicar a Blazor que descargue un ensamblado cuando se necesite por primera vez. Para que esto funcione, primero debemos registrar los ensamblajes con carga diferida en el archivo del proyecto. Luego, efectivamente, necesitaremos conectarnos al sistema de navegación, donde escucharemos si el usuario navega, en nuestro caso, a la página de detalles. Entonces, dado que está relacionado con la navegación, debemos mirar el enrutador y hacer cambios en la aplicación Razor. En el código allí, usaremos el LazyAssemblyLoader, que necesitaremos inyectar, y veremos esto en una demostración en solo un segundo. Luego, escucharemos en el enrutador cuándo ocurre la navegación y simplemente nos conectaremos a OnNavigateAsync. Cuando ocurra esta navegación, este evento se desencadenará y, allí, escribiremos un código que, en nuestro caso, verificará si estamos navegando por primera vez a la página de detalles. Si ese es el caso, querremos cargar la biblioteca de clases de Razor en el ensamblaje que contiene el componente de mapa. Blazor lo carga de forma asíncrona para nosotros mediante una llamada de JavaScript asíncrona. Y luego el ensamblaje se cargará en el tiempo de ejecución. Por lo tanto, se puede usar de manera regular, como si se hubiera cargado inicialmente. Incluso si el ensamblado descargado contiene nuevas rutas, por lo que las nuevas directivas @page también se pueden usar con un ensamblado con carga diferida. Luego, escucharemos en el enrutador cuándo ocurre la navegación y simplemente nos conectaremos a OnNavigateAsync. Cuando ocurra esta navegación, este evento se desencadenará y, allí, escribiremos un código que, en nuestro caso, verificará si estamos navegando por primera vez a la página de detalles. Si ese es el caso, querremos cargar la biblioteca de clases de Razor en el ensamblaje que contiene el componente de mapa. Blazor lo carga de forma asíncrona para nosotros mediante una llamada de JavaScript asíncrona. Y luego el ensamblaje se cargará en el tiempo de ejecución. Por lo tanto, se puede usar de manera regular, como si se hubiera cargado inicialmente. Incluso si el ensamblado descargado contiene nuevas rutas, por lo que las nuevas directivas @page también se pueden usar con un ensamblado con carga diferida. Luego, escucharemos en el enrutador cuándo ocurre la navegación y simplemente nos conectaremos a OnNavigateAsync. Cuando ocurra esta navegación, este evento se desencadenará y, allí, escribiremos un código que, en nuestro caso, verificará si estamos navegando por primera vez a la página de detalles. Si ese es el caso, querremos cargar la biblioteca de clases de Razor en el ensamblaje que contiene el componente de mapa. Blazor lo carga de forma asíncrona para nosotros mediante una llamada de JavaScript asíncrona. Y luego el ensamblaje se cargará en el tiempo de ejecución. Por lo tanto, se puede usar de manera regular, como si se hubiera cargado inicialmente. Incluso si el ensamblado descargado contiene nuevas rutas, por lo que las nuevas directivas @page también se pueden usar con un ensamblado con carga diferida. Cuando ocurra esta navegación, este evento se desencadenará y, allí, escribiremos un código que, en nuestro caso, verificará si estamos navegando por primera vez a la página de detalles. Si ese es el caso, querremos cargar la biblioteca de clases de Razor en el ensamblaje que contiene el componente de mapa. Blazor lo carga de forma asíncrona para nosotros mediante una llamada de JavaScript asíncrona. Y luego el ensamblaje se cargará en el tiempo de ejecución. Por lo tanto, se puede usar de manera regular, como si se hubiera cargado inicialmente. Incluso si el ensamblado descargado contiene nuevas rutas, por lo que las nuevas directivas @page también se pueden usar con un ensamblado con carga diferida. Cuando ocurra esta navegación, este evento se desencadenará y, allí, escribiremos un código que, en nuestro caso, verificará si estamos navegando por primera vez a la página de detalles. Si ese es el caso, querremos cargar la biblioteca de clases de Razor en el ensamblaje que contiene el componente de mapa. Blazor lo carga de forma asíncrona para nosotros mediante una llamada de JavaScript asíncrona. Y luego el ensamblaje se cargará en el tiempo de ejecución. Por lo tanto, se puede usar de manera regular, como si se hubiera cargado inicialmente. Incluso si el ensamblado descargado contiene nuevas rutas, por lo que las nuevas directivas @page también se pueden usar con un ensamblado con carga diferida. querremos cargar la biblioteca de clases de Razor en el ensamblaje que contiene el componente de mapa. Blazor lo carga de forma asíncrona para nosotros mediante una llamada de JavaScript asíncrona. Y luego el ensamblaje se cargará en el tiempo de ejecución. Por lo tanto, se puede usar de manera regular, como si se hubiera cargado inicialmente. Incluso si el ensamblado descargado contiene nuevas rutas, por lo que las nuevas directivas @page también se pueden usar con un ensamblado con carga diferida. querremos cargar la biblioteca de clases de Razor en el ensamblaje que contiene el componente de mapa. Blazor lo carga de forma asíncrona para nosotros mediante una llamada de JavaScript asíncrona. Y luego el ensamblaje se cargará en el tiempo de ejecución. Por lo tanto, se puede usar de manera regular, como si se hubiera cargado inicialmente. Incluso si el ensamblado descargado contiene nuevas rutas, por lo que las nuevas directivas @page también se pueden usar con un ensamblado con carga diferida.

**Demostración: ensamblajes de carga diferida**

Volvamos una vez más a Visual Studio y hagamos los cambios para que el ensamblado de la biblioteca de clases de Razor ahora se cargue solo cuando sea necesario. Lo que me gustaría lograr con esta demostración es que en la carga inicial de la aplicación Blazor, solo se descargue la DLL principal que contiene nuestra aplicación Blazor, pero cuando navego a Empleados, todos los detalles, pero solo en ese momento descargue la clase Razor biblioteca que contiene nuestro mapa. Eso reducirá el tiempo de carga inicial de la aplicación, y eso es exactamente lo que busco aquí. Para agregar este tipo de carga diferida, que es exactamente lo que voy a agregar, debo comenzar haciendo un cambio en el archivo del Proyecto. En el archivo de proyecto, necesito hacer referencia a qué ensamblaje, qué DLL, se va a cargar de forma diferida. Para eso, necesito agregar una entrada de ItemGroup aquí, especificando que nuestra biblioteca de componentes se cargará de forma diferida. Ahora solo agregar esto no resuelve nada todavía. Ahora también necesito decir manualmente cuándo, en qué punto de la aplicación, quiero que se descargue esta DLL. Y tenga en cuenta que, por supuesto, puede hacer esto con varias DLL. Para especificar eso, voy a ir a App.razor, y aquí vive el enrutador, ese es el componente que ya vimos que maneja toda la navegación. Lo que voy a hacer es escribir un código que se conecte a los eventos de navegación del enrutador, y voy a escribir un código que verificará si estamos navegando efectivamente a la página de detalles y, de ser así, luego vamos a descargar nuestra DLL, nuestra biblioteca de Componentes, es decir. Ahora vamos a solicitar la ayuda de LazyAssemblyLoader, ese es un servicio que una aplicación Blazor registra automáticamente, por lo que no necesitamos hacer nada para eso, por lo que podemos usar nuevamente la inyección de dependencia e inyectar ese servicio aquí. Aquí, estoy inyectando el LazyAssemblyLoader. Así que esto nos ayudará a cargar nuestra biblioteca de componentes de forma perezosa. Ahora voy a usar, en este caso, un bloque de código. Por supuesto, también podríamos usar una clase de componente, y aquí creo una nueva lista de ensamblajes. En el enrutador, especificaré cuáles son los ensamblajes adicionales con los que puede necesitar trabajar y, como se dijo, conectaré el método @OnNavigateAsync, un método llamado por el enrutador cuando estamos navegando. Permítanme agregar la implementación para OnNavigateAsync. Aquí, en OnNavigateAsync, Voy a comprobar si la ruta por la que estamos navegando contiene la palabra detalle del empleado. Si ese es el caso, usaré LazyAssemblyLoader y le pediré que cargue de forma diferida BethanysPieShoptHRP.ComponentsLibrary.dll. Esto va a utilizar la interoperabilidad de JavaScript para obtener la DLL, especificada aquí, mediante una llamada de red asíncrona. Luego, voy a agregar un ensamblaje a esta lista de ensamblajes, y esa lista de ensamblajes, como se especifica aquí en el enrutador, tiene el valor de los ensamblajes adicionales. Entonces, cuando se carga una nueva DLL, se descargará usando este código, y luego el enrutador la verá automáticamente usando estos ensamblajes adicionales. Pongamos un punto de interrupción aquí. Esa es la forma más fácil de ver cómo funciona esto ahora. Voy a ejecutar la aplicación de nuevo. automáticamente verá que se está alcanzando el punto de interrupción, pero simplemente omitirá el código. Si vamos a Empleados, nuevamente, se alcanzará el punto de interrupción, el primero que sea, pero nuevamente, no se descargará ningún ensamblaje. Si ahora hago clic en Detalles completos, en este punto, dado que la ruta contiene detalles de empleado, se cargará el ensamblaje, se iniciará una llamada de red mediante la interoperabilidad de JavaScript, se cargará el ensamblaje y nuestro mapa seguirá funcionando como antes, pero fue descargado de forma perezosa.

**Resumen**

Y con eso, hemos llegado al final de este módulo. El objetivo principal aquí era mostrarle que cualquier funcionalidad faltante en Blazor, pero disponible a través de JavaScript, se puede incorporar a la interoperabilidad de JavaScript. Que mostramos aquí al crear un componente de mapa, que usa JavaScript para representar el mapa dentro de nuestra aplicación Blazor. Luego, movimos el componente a una biblioteca separada para la cual usamos la plantilla Razor Cass Library. Y, por último, hemos aumentado la velocidad de inicio de nuestra aplicación mediante la carga diferida de la biblioteca de clases de Razor para que solo se descargue cuando sea necesario por primera vez. En el siguiente módulo, aprenderemos mucho sobre cómo podemos proteger nuestra aplicación. Traeremos autenticación y autorización.
