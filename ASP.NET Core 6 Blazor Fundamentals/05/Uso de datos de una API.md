# Uso de datos de una API

Cátedra Programación de Software y Programática - Fundamentos de ASP.NET Core 6 Blazor

Introducción al módulo

Hasta ahora, hemos creado nuestra aplicación utilizando datos simulados. Hemos utilizado datos codificados de forma rígida. Eso nos dio la oportunidad de centrarnos en aprender más sobre los componentes. Si bien todavía hay más que aprender en esa área, centrémonos ahora en el lado de los datos. En este módulo, vamos a cargar datos desde una API y, mientras lo hacemos, aprenderemos muchas otras cosas interesantes, incluida la inserción de dependencias en Blazor. Soy Gill Cleeren y seré su guía a través de este módulo. Entonces, como se dijo, el objetivo principal de este módulo es reemplazar los datos codificados con datos provenientes de una API. Antes de comenzar a usar una API de Blazor, lo guiaré a través de la API que usaremos y le explicaré lo que necesita comprender en esta área. Luego, usaremos la clase HttpClient para comunicarnos con la API de Blazor. Mencioné que aprenderemos algunas otras cosas interesantes aquí, y no estaba mintiendo. También veremos la administración del estado, de modo que podamos mantener los datos dentro de la aplicación Blazor en ejecución y, por lo tanto, reducir la carga en la API. Otra forma de hacerlo es almacenando datos localmente, y ese será el último tema que cubriremos en este módulo. Un montón de cosas interesantes si me preguntas. Empecemos.
	

Trabajar con una API

Muy bien, primero, aprenderemos más sobre las API. Ya mencioné en la introducción del módulo que es raro que cree una aplicación con datos codificados de forma rígida. Nuestra aplicación Blazor necesitará acceso a datos reales y actualizados, entonces, ¿cómo accedemos a esos datos desde una aplicación Blazor? Para trabajar con datos reales en una aplicación Blazor, en realidad tenemos un par de opciones. En la mayoría de los casos, una aplicación necesitará acceso a datos del lado del servidor, por lo tanto, datos actualizados que necesita recuperar en otro lugar. Una aplicación WebAssembly Blazor del lado del cliente no se conectará mediante, por ejemplo, Entity Framework Core a una base de datos del lado del servidor. En este caso, nuestra aplicación Blazor necesitaría las credenciales de la base de datos para iniciar sesión en esa base de datos remota, definitivamente no es una buena idea. Sin embargo, es posible trabajar con EF Core de Blazor en la aplicación Blazor Server, pero eso no es lo que estamos usando aquí. Entonces, lo que necesitaremos es una mejor manera, y eso es usar una API REST. En este caso, usaremos la comunicación HTTP para obtener datos de una base de datos que se encuentra detrás de un servicio. Una segunda opción para trabajar con datos es usar almacenamiento local, por lo tanto, puramente del lado del cliente. En este caso, podemos usar la función de almacenamiento local del navegador para almacenar datos, por ejemplo, en formato JSON, y usarlos en nuestra aplicación Blazor. Por supuesto, estos son solo datos locales, no nos darán la opción de obtener datos actualizados de nuestro back-end en sí mismo. Pero es interesante saber que Blazor realmente puede hacer esto. Esta también puede ser una característica muy útil, en caso de que decida crear una aplicación Blazor que necesite funciones sin conexión. De hecho, puede usar el almacenamiento local para almacenar datos y, cuando la conexión vuelva a estar disponible, enviar cualquier cambio fuera de línea al servidor. Cuando hablamos de una API, estamos buscando una forma de interactuar con un servidor para obtener acceso solo a los datos. Usando ASP.NET Core MVC, por ejemplo, estamos recuperando HTML, el navegador representará una página web completa. En nuestra aplicación Blazor, solo nos interesan los datos en lugar del HTML. Ahí es donde entra en juego una API o un servicio. Al igual que con un método, devolveremos datos a la persona que llama. La persona que llama aquí será el cliente, por lo que en nuestro caso es la aplicación Blazor, que no quiere el HTML completo, pero solo quiere los datos. En la API, definiremos un punto final que devuelva, de hecho, solo los datos. Con solo los datos, me refiero típicamente a los datos en formato JSON o XML. Ambas son formas de representar los datos. JSON, que significa Notación de objetos de JavaScript, es una forma muy compacta de representar datos en un formato de clave-valor, y eso es lo que usaremos con más frecuencia. Tanto JSON como XML son estándares y se utilizan en muchas tecnologías. Vamos a trabajar con una API que se crea con ASP.NET Core, y esa API se puede consumir desde muchos otros tipos de clientes, por ejemplo, una aplicación MAUI o Xamarin.Forms, otra API, una aplicación de escritorio o incluso una aplicación nativa de iOS. Y por supuesto, también desde una aplicación Blazor WebAssembly. El tipo de API que crearemos en este caso es una API RESTful. REST es nuevamente una abreviatura, que significa Transferencia de estado representacional. Una API RESTful usa los estándares HTTP y sigue algunas reglas. Cuando creamos una API RESTful, lo que vamos a hacer es aceptar solicitudes HTTP entrantes. Los clientes pueden enviar a la API un GET, POST, PUT, etc. Eso es, de hecho, cosas bastante comunes. Los clientes enviarán esta solicitud a un recurso a través de una URL normal. Un recurso es prácticamente todo lo que podemos abordar a través de una URL. Digamos, por ejemplo, que vamos a crear una API que nos devolverá una lista de todos los empleados. Bueno, ese punto final es un recurso y será direccionable a través de una URL única y regular. Cuando se recibe la solicitud, la API responderá utilizando JSON. Los datos, en nuestro caso, la lista de empleados, se incluirán normalmente en JSON y se devolverán al cliente junto con un código de estado. Si todo va bien, la API devolverá un código de estado 200, que es el código de estado HTTP de OK, todo salió bien y aquí están los datos que deseaba. También se pueden devolver otros códigos de estado. Digamos que tenemos un punto final que puede devolver los detalles de un empleado y estamos pasando la identificación de un empleado que no existe. En ese caso, la API debería devolver 404, el conocido código de estado HTTP para no encontrado. En resumen, una API RESTful se basa en estos conceptos básicos y eso es lo que usaremos aquí también. Aquí puedes ver esto en acción. La aplicación Blazor que se ejecuta dentro del navegador del usuario enviará una solicitud a un recurso. La solicitud es una solicitud HTTP normal, por ejemplo, una solicitud GET a un determinado recurso representado por la URL. En la API, construida con ASP.NET Core en nuestro caso, se recibe esta solicitud y activará la ejecución del código. Si todo va bien, se envía una respuesta al cliente. Esa respuesta normalmente tendrá un código de estado, que indica cómo el servidor podría manejar la solicitud. Con suerte, este será el estado 200 si todo va bien, y probablemente se incluirán datos JSON. En base a esta respuesta, el cliente puede actuar en consecuencia. Según el verbo HTTP, una API REST realizará una determinada acción. De hecho, el verbo HTTP que aparece determinará lo que debe hacer la API. Estos son los verbos HTTP más comunes. GET significa dame un resultado. POST se usa para crear una nueva instancia o registro, por lo general. Digamos que está creando una API que permite crear nuevos empleados. La solicitud POST normalmente contendrá todos los datos para crear un empleado en el servidor e insertarlo en la base de datos. Un PUT es para solicitudes de actualización, por lo que, si queremos actualizar el empleado del cliente, enviaremos un empleado actualizado combinado con el verbo HTTP PUT. Si queremos realizar una eliminación, entonces podemos usar el verbo HTTP DELETE. Ya he mencionado JSON varias veces. Como se mencionó, es la forma más utilizada para enviar y recibir datos de una API. Es compacto y, por lo tanto, se incurre en muy pocos gastos generales. Es un estándar y se puede consumir fácilmente en muchas tecnologías. Puede ver un fragmento de JSON para representar un conjunto de empleados. Cada empleado se representa como un objeto JSON, por lo tanto, entre llaves, y cada propiedad de datos se representará mediante un par clave-valor. La clave es el nombre de la propiedad, mientras que el valor son los datos reales, el valor de la propiedad. De hecho, aquí se representa todo el conjunto de empleados como una matriz JSON, que podemos ver mediante los corchetes que rodean los diferentes objetos JSON. Ahora no escribiremos ningún JSON nosotros mismos, haremos que nuestra API cree el JSON en función de los objetos que le entreguemos.

Demostración: Explorando la API

Ahora, dado que este no es un curso sobre la creación de una API, para el propósito de este curso he incluido una API completamente funcional que también podemos usar. He usado ASP.NET Core para construir esta API. En esta demostración, permítame mostrarle esa API. Voy a mostrarles la API a continuación. De hecho, se incluye nuevamente con los activos que vienen con las descargas de este curso. Si va a M5, allí encontrará un proyecto de API, BethanysPieShopHRM.Api. Copie esa carpeta a su carpeta de solución y luego agréguela a la solución yendo a Agregar, Proyecto existente nuevamente y luego seleccionando el proyecto API. Lo guiaré a través de la API muy brevemente. Es una API normal creada con ASP.NET Core, por lo que es un proyecto de .NET 6 nuevamente. Si va a LaunchSettings aquí en Propiedades, veremos que la API puede ejecutarse en el puerto 7039. Entonces localhost: 7039 será la URL a la que podemos dirigirnos para hablar con la API. En Program.cs, agregaremos los servicios necesarios al contenedor de inserción de dependencias y también agregaremos el middleware necesario. Usaremos EF Core para hablar con la base de datos. Los datos realmente vivirán en una base de datos que se encuentra detrás de la API. En la configuración de la aplicación, he definido una cadena de conexión llamada DefaultConnection. Entonces, al usar el bloque div aquí, estoy especificando que voy a usar DbContext, y los datos realmente deberán recuperarse de SQL Server usando esta cadena de conexión. Vamos a usar un par de repositorios, y esos están registrados aquí, y les mostraré esos en solo un minuto. Y también he añadido CORS para que desde cualquier URL se permita cualquier cabecera y cualquier método. Vamos a usar AddControllers aquí. Eso es básicamente agregar soporte para MVC, el patrón basado en MVC, pero no estamos usando AddControllers con el uso ya que este es solo un proyecto de API. Y también se agrega Swagger para poder navegar hasta el punto final de la API abierta. En el middleware hay un conjunto predeterminado de middleware que ya se está agregando. Por ejemplo, tenemos soporte para archivos estáticos, el enrutamiento está habilitado, la autorización está habilitada, CORS está conectado, esa es la política que se definió hace un minuto, y también especificamos un punto final para los controladores y, finalmente, llamamos app Ejecutar, que iniciará la aplicación y escuchará las solicitudes entrantes. Ahora, en términos de controladores, hay un par de controladores que he definido. El EmployeeController, echemos un vistazo a eso primero. Es direccionable a través de esta ruta, entonces api/ el nombre del controlador, entonces api/empleado para este. También agregué el atributo ApiController y heredo del controlador. En esta versión de EmployeeController, por lo que sin tener en cuenta lo comentado, uso un IEmployeeRepository, que está conectado a una inyección de dependencia, como podemos ver aquí. La inyección de constructor se usa para pasar una instancia de employeeRepository. La asignación se definió aquí dentro de Program.cs. Luego definí un par de métodos en la API. HttpGet GetAllEmployees devolverá, a través de _employeeRepository, a todos los empleados. Tengo la capacidad de pasar una identificación y obtener un empleado por identificación. También puedo crear un empleado, que recibe al Empleado en el cuerpo. Allí voy a realizar algunas comprobaciones. Si el empleado es nulo, devuelvo una BadRequest. También tengo una regla comercial definida aquí que establece que el nombre y el apellido del empleado no deben estar vacíos. Si el modelo no es válido, entonces devolveré una BadRequest, lo que significa que probablemente se violaron estas reglas comerciales. Omitiremos el código comentado por ahora. Y crearé el empleado usando el repositorio y devolveré un 201 Creado. UpdateEmployee es bastante similar, como podemos ver aquí. Y también he creado un DeleteEmployee, que acepta una identificación. Veamos rápidamente los repositorios dentro de la carpeta Modelos. Entonces, solo IEmployeeRepository he definido estos métodos, GetAll, get ById, Add, Update y Delete. Y esos se implementan dentro de EmployeeRepository. Y allí inyecto el AppDbContext, nuevamente a través de la inyección de dependencia. Para obtener todos los empleados, solicito el _appDbContext para los empleados. El ById hará un FirstOrDefault, pasando el EmployeeId. AddEmployee adjuntará un empleado a Employees DbSet y luego llamará a SaveChanges. Y también devolverá la entidad agregada. UpdateEmployee primero recuperará al empleado de _appDbContext, lo actualizará y luego llamará a SaveChanges. Y también hay DeleteEmployee, y creo que podemos averiguar qué hará. Al lado de EmployeeController también hay CountryController, que es muy similar. Utiliza un countryRepository, que se inyecta nuevamente a través de la inyección de dependencia. Y tenemos GetCountries y GetCountryById. Y de manera muy similar, se puede usar JobCategoryController para recuperar todas las categorías de trabajo o una categoría de trabajo por ID. Ahora, finalmente, echemos un vistazo a AppDbContext. Todavía no te he mostrado ese. En AppDbContext, por supuesto, tenemos un par de DbSets definidos, empleados, países y categorías de trabajo. En OnModelCreating, he usado HasData para sembrar la base de datos con algunos datos iniciales. Si todavía no hay datos en mi base de datos, se agregarán estos datos iniciales. Ahora, por supuesto, para que eso suceda, necesito crear una migración. Voy a ir a Ver, Otras ventanas y luego a la Consola del administrador de paquetes. Asegúrese de configurar el proyecto API como el proyecto predeterminado. Luego, voy a crear una migración inicial diciendo agregar migración, es decir agregar migración, y le daré un nombre, MigraciónInicial. Y eso de hecho creará una clase InitialMigration, que tiene un método Up que creará la tabla de países, categorías de trabajo y empleados. Y también incluirá los datos que he definido dentro del DbContext. Vuelvo a mi Consola del administrador de paquetes y ahora llamo a la base de datos de actualización. Esto ahora ha creado con éxito mi base de datos. Si ahora ejecuto la aplicación, entonces con el proyecto API configurado como inicio, obtendremos el punto final de Swagger que luego podemos usar para probar nuestra API. Aquí está nuestro punto final de Swagger. Pidamos, por ejemplo, que nos devuelvan a todos los empleados. Y obtuvimos, en este caso, solo un empleado porque acababa de insertar un empleado en el DbContext. Si miramos, por ejemplo, a los países y llamamos a /api/Country, eso hará un GET para obtener todos los países de la API. Y esto, por supuesto, ahora son datos que provienen de la base de datos. Eso es lo que necesitamos en nuestra aplicación Blazor. y ahora llamo update‑database. Esto ahora ha creado con éxito mi base de datos. Si ahora ejecuto la aplicación, entonces con el proyecto API configurado como inicio, obtendremos el punto final de Swagger que luego podemos usar para probar nuestra API. Aquí está nuestro punto final de Swagger. Pidamos, por ejemplo, que nos devuelvan a todos los empleados. Y obtuvimos, en este caso, solo un empleado porque acababa de insertar un empleado en el DbContext. Si miramos, por ejemplo, a los países y llamamos a /api/Country, eso hará un GET para obtener todos los países de la API. Y esto, por supuesto, ahora son datos que provienen de la base de datos. Eso es lo que necesitamos en nuestra aplicación Blazor. y ahora llamo update‑database. Esto ahora ha creado con éxito mi base de datos. Si ahora ejecuto la aplicación, entonces con el proyecto API configurado como inicio, obtendremos el punto final de Swagger que luego podemos usar para probar nuestra API. Aquí está nuestro punto final de Swagger. Pidamos, por ejemplo, que nos devuelvan a todos los empleados. Y obtuvimos, en este caso, solo un empleado porque acababa de insertar un empleado en el DbContext. Si miramos, por ejemplo, a los países y llamamos a /api/Country, eso hará un GET para obtener todos los países de la API. Y esto, por supuesto, ahora son datos que provienen de la base de datos. Eso es lo que necesitamos en nuestra aplicación Blazor. obtendremos el punto final de Swagger que luego podemos usar para probar nuestra API. Aquí está nuestro punto final de Swagger. Pidamos, por ejemplo, que nos devuelvan a todos los empleados. Y obtuvimos, en este caso, solo un empleado porque acababa de insertar un empleado en el DbContext. Si miramos, por ejemplo, a los países y llamamos a /api/Country, eso hará un GET para obtener todos los países de la API. Y esto, por supuesto, ahora son datos que provienen de la base de datos. Eso es lo que necesitamos en nuestra aplicación Blazor. obtendremos el punto final de Swagger que luego podemos usar para probar nuestra API. Aquí está nuestro punto final de Swagger. Pidamos, por ejemplo, que nos devuelvan a todos los empleados. Y obtuvimos, en este caso, solo un empleado porque acababa de insertar un empleado en el DbContext. Si miramos, por ejemplo, a los países y llamamos a /api/Country, eso hará un GET para obtener todos los países de la API. Y esto, por supuesto, ahora son datos que provienen de la base de datos. Eso es lo que necesitamos en nuestra aplicación Blazor. Y esto, por supuesto, ahora son datos que provienen de la base de datos. Eso es lo que necesitamos en nuestra aplicación Blazor. Y esto, por supuesto, ahora son datos que provienen de la base de datos. Eso es lo que necesitamos en nuestra aplicación Blazor.

Demostración: Pasar a ASP.NET Core alojado

Hasta ahora, hemos utilizado nuestra aplicación Blazor como una aplicación independiente, alojada en index.html. Ahora convertiré nuestra aplicación Blazor para que se convierta en una aplicación ASP.NET Core Hosted Blazor. Voy a alojar la aplicación Blazor en la misma aplicación desde donde ejecuto mi API, y esa es, de hecho, una aplicación ASP.NET Core. Entonces, de hecho, lo que estoy cambiando es quién aloja la aplicación Blazor. Lo incluyo en la aplicación ASP.NET Core que le mostré para la API. La aplicación sigue siendo una aplicación Blazor WebAssembly, aún se descarga en el cliente. Lo único que cambia es que el servidor en el que ahora se alojará requiere .NET, no para la parte de Blazor, sino para la API. En esta próxima demostración, le mostraré lo que cambié para que mi aplicación Blazor ahora se convierta en un ASP. Aplicación Blazor WASM alojada en NET Core. Wow, eso es un bocado. Hasta ahora, cuando ejecutamos nuestra aplicación Blazor, este proyecto aquí era de hecho el proyecto inicial. De hecho, cuando ejecutamos nuestra aplicación, se invocó el index.html que se encuentra aquí. Ahora voy a cambiar la configuración del proyecto API, para que luego se convierta en el proyecto de hospedaje de nuestra aplicación Blazor. Nuestra aplicación Blazor seguirá siendo una aplicación Blazor WebAssembly, pero se hospedará como parte del proyecto API, y ese es un proyecto .NET Core. De hecho, dentro de Visual Studio hay una plantilla que también hace esto por usted, pero me gusta configurarla yo mismo para saber qué está pasando y usted también. Voy a configurar mi proyecto de API para que pueda alojar la aplicación Blazor. Primero vamos a incorporar un paquete NuGet, Microsoft. Paquete AspNetCore.Components.WebAssembly.Server. Esto es necesario porque contiene el middleware necesario para que Blazor se pueda servir a través de nuestro proyecto API, que es un proyecto ASP.NET Core normal. Con ese paquete agregado, guarde esto, luego vayamos a nuestro Program.cs. Asegúrese de ir a Progam.cs del proyecto API, no a la aplicación Blazor. Ahora configuraremos esto para que luego pueda hospedar la aplicación Blazor. Traeré algo de middleware. Debajo del builder.Build, ahora he agregado primero esta parte aquí. Esto traerá el middleware necesario para la depuración de Blazor WebAssembly. Esto solo lo necesito si el ambiente es de desarrollo. A continuación, debo incorporar el componente de middleware UsedBlazorFrameworkFiles, que será necesario para atender la aplicación Blazor desde el proyecto de la API. UseStaticFiles ya estaba allí, definitivamente es necesario porque, de hecho, nuestra aplicación Blazor se servirá como archivos estáticos. También agregaré aquí un punto final y diré que si una solicitud entrante no se puede enrutar a uno de los controladores configurados a través de su enrutamiento, los redirigiré a index.html. Ese es el index.html que aún forma parte de mi aplicación Blazor, pero dado que mi aplicación Blazor no se hospedará desde mi proyecto API, es este index.html al que enrutaremos a los usuarios. También necesito hacer un cambio en la configuración de lanzamiento. En la configuración de inicio, ahora hay un LaunchURL para swagger definido, no quiero eso, voy a reemplazarlo con lo siguiente, y puede encontrar este en los fragmentos. El URI de inspección es necesario para que Visual Studio sepa que necesita depurar Blazor y cómo hacerlo, y para estar seguro, necesito hacerlo en ambos perfiles, dependiendo de cuál usaremos para ejecutar la aplicación desde . Finalmente, una cosa más, necesitamos agregar una referencia del proyecto API al proyecto Blazor WebAssembly. Con esas cosas hechas, ahora podemos ejecutar el proyecto API. Como puede ver, todavía estaba configurado como un proyecto de inicio y ahora ejecutará nuestra aplicación Blazor desde su raíz. De hecho, ahora estamos ejecutando en otro puerto, 7039, es el puerto que se definió aquí como la URL de la aplicación en el proyecto API, y no estamos solicitando ningún punto final API para devolver una respuesta, no, solo estamos navegando a la raíz, y eso es atendido por index.html. Se nos redirige a nuestra aplicación Blazor, que funciona, como lo hizo antes. Así que ahora nuestra aplicación Blazor se sirve desde el proyecto API, y es solo este proyecto el que necesitaremos implementar más adelante en este curso.

Acceder a los datos de la API mediante HttpClient

Nuestra API está en funcionamiento, es hora de comenzar a usarla desde Blazor y, para eso, usaremos HttpClient. Cuando se trabaja con API, desde aplicaciones cliente como nuestra aplicación Blazor, hay algunos tipos importantes con los que tendremos que trabajar. Creo que la más importante es la clase HttpClient. Esto lo usaremos para enviar nuestras llamadas HTTP. El segundo tipo, una interfaz por cierto, que es importante en esta área es IHttpClientFactory. Cuando trabajemos con HttpClient, de hecho, usaremos el servicio HttpClient, y eso debe inyectarse en el contenedor de inserción de dependencias en nuestra aplicación Blazor antes de que podamos usarlo. Las aplicaciones de Blazor son, como ya mencioné, muy similares a las aplicaciones de ASP.NET Core, y allí también, todo evoluciona en torno a la inyección de dependencia. Está integrado en la plataforma. Como una pequeña nota al margen, déjame explicarte la inyección de dependencia para que tengas la comprensión necesaria de qué se trata DI, o inyección de dependencia para abreviar. La inyección de dependencia nos ayudará a crear un código más débilmente acoplado. Imagine que tenemos una clase, aquí MyClass, y necesita un LoggerService. En lugar de crear una instancia de LoggerService directamente en MyClass, lo que crearía una dependencia fuerte entre los dos, incorporamos dos cosas, una interfaz, ILoggerService y un contenedor de inyección de dependencia, es decir, un contenedor DI. El contenedor puede ser visto como el punto central de información. Registramos allí que cuando alguien necesita un ILoggerService, obtendrá un LoggerService. MyClass luego le preguntará al contenedor, ¿puedo obtener un ILoggerService? Según los registros que se hayan producido, el contenedor devolverá una instancia concreta de LoggerService. Ahora hemos desacoplado las cosas y eso las hace mucho más fáciles. Además, ya no necesitamos crear todos los objetos requeridos nosotros mismos, eso también lo manejan los contenedores. La buena noticia es que, como se dijo, ASP.NET Core viene con el contenedor DI incluido en el paquete, y las aplicaciones de Blazor también harán uso de ese contenedor. Así que ahora veamos cómo podemos trabajar desde el código con HttpClient, y comenzaré con el enfoque básico, donde usamos el servicio HttpClient directamente. Primero, debemos en el Programa, registrar el servicio HttpClient con la colección de servicios. La colección de servicios es la colección de servicios registrados en la parte del contenedor de inserción de dependencias de Blazor. Con las líneas de código que ve aquí en la diapositiva, estamos registrando el servicio usando el método AddScoped. AddScoped es un método que registra tipos con el contenedor de inyección de dependencia con una vida útil limitada, lo que significa que se crea una instancia y se mantiene. También pasamos la dirección base donde reside la API. Si es necesario, esta dirección de punto final también se puede recuperar, por ejemplo, de un archivo de configuración JSON, pero para simplificar, la codifiqué aquí. Una vez que haya registrado el servicio, ahora puede usarlo directamente en su componente. En un componente, podemos acceder a servicios dentro de la colección de servicios registrados en el contenedor de inyección de dependencia, utilizando el atributo Inyectar. De hecho, ya hemos visto que esto se usa varias veces. Si no recuerdo mal, también lo habíamos usado para obtener una instancia de NavigationManager. Por lo tanto, este atributo garantizará que se recupere una instancia de HttpClient de la colección de servicios, si está disponible. Registrarse, como le mostré en la diapositiva anterior, es lo que se necesita para que esto funcione. Tenga en cuenta que el atributo Inject se puede usar solo en componentes, no en otras clases en las que es posible que necesitemos una instancia de HttpClient. Ahora que el sistema de inyección de dependencia nos dio acceso a una instancia de HttpClient, podemos usarla. Se agregó un conjunto de métodos de ayuda que hace que la interacción con la API REST sobre JSON sea muy simple. Eche un vistazo al fragmento que ve aquí en la diapositiva. Estoy usando el método GetFromJsonAsync, que es un método genérico. Como parámetro de tipo, especificamos que queremos que la respuesta se devuelva como una matriz de instancias de empleados. Esto ahora dará como resultado que se envíe una solicitud HTTP al punto final de API/empleado. Debido a que HttpClient se configuró con su dirección base en la clase Program, se usará la URL completa para realizar esta solicitud HTTP. Hay bastantes métodos disponibles en HttpClient para ayudarnos con la comunicación con un back-end REST. Ya hemos visto GetFromJsonAsync, que como su nombre lo indica, se usa para recuperar una cadena JSON de nuestra API. También hay un método PostAsJsonAsync. A este método, le pasamos los datos que queremos insertar en nuestro back-end como una cadena JSON. De manera similar, el método PutAsJsonAsync se usa para actualizar una instancia, y a este método también le pasaremos el objeto que queremos actualizar, nuevamente como JSON. No existe una alternativa real para eliminar una instancia, aunque existe un método de extensión llamado DeleteAsync, y que se puede usar para enviar una solicitud DELETE a la API. Esta API de HttpClient funciona bien directamente en los componentes. Sin embargo, usaré un enfoque basado en IHttpClientFactory, que en mi humilde opinión es el mejor enfoque para usar. Nos brinda la capacidad de crear y configurar instancias de HttpClient en una ubicación central, y también podemos crear instancias de HttpClient con nombre y tipo. Pronto veremos cuáles son. Además, su clase de código subyacente debe permanecer limpia y sugiero no escribir demasiado código allí. Por lo tanto, sugiero escribir código que interactúe con la API REST en una clase separada. Esto se puede lograr fácilmente usando IHttpClientFactory. El uso de IHttpClientFactory en nuestra aplicación requiere que traiga un paquete NuGet adicional, el paquete Microsoft.Extensions.Http. Para utilizar IHttpClientFactory, primero tendremos que volver a nuestro programa y registrar HttpClientFactory con la colección de servicios. Eso es lo que ven aquí en las diapositivas. Ahora uso el método AddHttpClient en lugar de AddScoped y, de hecho, es un poco confuso cuando se trata de nombrar los métodos. El método de extensión AddHttpClient se usa para brindar soporte para IHttpClientFactory. Estamos usando aquí el enfoque HttpClient escrito. Como acabo de mencionar, no me gusta poner demasiado código en mis componentes, y definitivamente no el código que interactuará con mi API REST. Por lo tanto, sugiero escribir código que interactúe con la API REST en una clase separada. Tiendo a llamar a estas clases clases de servicio ya que normalmente tienen una sola tarea, en este caso, interactuar con la API para obtener y enviar datos. Aquí estamos registrando que EmployeeDataService, que veremos en la demostración, se registrará con la colección de servicios y obtendrá una instancia de HttpClient de IHttpClientFactory inyectada. Nuevamente, la configuración se realiza aquí. El punto final y, opcionalmente, otra configuración para conectarse con la API se agrega aquí. Aquí verá la implementación de EmployeeDataService implementando la interfaz IEmployeeDataService, que se utilizó para registrar el servicio en la colección de servicios. Esta clase contendrá la lógica real para interactuar con la API REST y, por lo tanto, también necesitará HttpClient. Ahora, el atributo Inyectar que les acabo de mostrar, como se mencionó, solo funciona en una clase de componente. Esta clase no es un componente, por lo que necesitaremos usar una forma diferente de ingresar al HttpClient. Lo que estoy usando aquí es la inyección de constructor. Como puede ver, estoy usando un parámetro constructivo de tipo HttpClient. Esto se inyectará ya que registramos IHttpClientFactory en la clase Program al inicio de nuestra aplicación.


Demostración: comunicación con la API mediante HttpClient

Muy bien, volvamos a nuestra demostración y reemplacemos el uso de los datos codificados con datos reales. Por lo tanto, traeremos soporte para HttpClient, crearemos un nuevo servicio de datos y lo usaremos desde nuestra página principal y de detalles. Ya está todo configurado. Tenemos nuestra API. Nuestro proyecto API ahora albergará nuestra aplicación Blazor. Es hora de usar esa API de nuestra replicación de Blazor y deshacerse de estos datos simulados, ¿verdad? Ahora, vamos a llegar a los extremos de la API mediante HttpClient y, de hecho, hay dos formas, como mencioné en las diapositivas, de hacerlo. La manera más fácil, pero definitivamente no siempre la mejor, es inyectar HttpClient directamente dentro del componente. Usando el código que ves aquí donde estoy inyectando un HttpClient en el componente, obtenemos acceso a HttpClient y podemos usarlo para realizar una solicitud a un punto final de API. Usando el atributo Inyectar, lo inyectaré aquí. Esta es la inyección de dependencia en el trabajo. HttpClient se puede configurar en la clase de programa y luego se inyectará una instancia de HttpClient directamente en el componente. Con esta instancia de HttpClient inyectada, podríamos usar el siguiente código que ve aquí. Podemos comunicarnos con nuestro punto final de API mediante GetFromJsonAsync. El argumento es el punto final, por lo que el URI del punto final, y automáticamente estos métodos GetFromJsonAsync, por lo que uno de los métodos integrados, convertirá esto en una lista de empleados. Para que esto funcione, como se mencionó, también necesitamos configurar HttpClient en la clase del programa. Aunque esto funciona, no soy realmente un fanático de usar HttpClient directamente en mis componentes. Prefiero que mis componentes sean livianos y que dependan de otra clase para realizar las llamadas HTTP reales. Eso es lo que voy a hacer aquí, y luego también usaremos la fábrica HttpClient, que es, en mi opinión, un enfoque más elegante para usar HttpClient. Así que voy a eliminar este código de nuevo aquí. Usaré el enfoque basado en IHttpClientFactory. Así que dije que voy a crear clases que contendrán toda la lógica para llegar a nuestra API. Así que voy a ir y crear una nueva carpeta donde colocaré estas clases, por ahora será solo una, y esa será la carpeta Servicios. Allí, crearé el IEmployeeDataService. Esa será una interfaz que contendrá las definiciones del método que quiero implementar y nuestra necesidad de comunicación HTTP. Así que agregaré aquí IEmployeeDataService como una clase, y convertiré esto en una interfaz, y definiré los métodos que necesitaremos. Permítanme agregar la declaración de uso correcta. He definido GetAllEmployees, que me devolverá un IEnumerable de empleados de forma asincrónica, por lo que lo he definido como una tarea. Tengo GetEmployeeDetails, que acepta un employeeId. También tengo un método Add and Update y DeleteEmployee. Esos corresponden, por supuesto, con los puntos finales de la API definidos en nuestro controlador. De hecho, estos serán los métodos que lleguen a esos puntos finales de la API. Entonces, creemos la implementación, agreguemos una clase aquí nuevamente, y será EmployeeDataService, y eso, por supuesto, implementará la interfaz IEmployeeDataService. Y ya hemos creado una implementación predeterminada aquí. Aquí vamos. Agregaré la implementación para esto en solo un minuto. Vayamos ahora primero a nuestra clase de programa, y ​​allí necesitaremos hacer los registros necesarios. Registraré con mi contenedor de inyección de dependencia que cuando se solicite un IEmployeeDataService, se recuperará una instancia de EmployeeDataService. Pero eso, donde creamos la implementación, requerirá un HttpClient. Y podemos usar IHttpClientFactory para hacer esto. Podemos, de hecho, registrar usando el método AddHttpClient una interfaz con su implementación, y si esa clase necesita un HttpClient, se inyectará una instancia automáticamente. Esa es la forma tipificada de hacer las cosas. Ahora, antes de que podamos usar IHttpClientFactory, debemos agregar un paquete NuGet. Voy a hacer clic con el botón derecho en mi proyecto y decir Administrar paquetes NuGet. Haga clic en Examinar y busque el paquete Microsoft.Extensions.Http. Haga clic en Instalar. Eso traerá ese paquete a nuestra aplicación. Aquí vamos. Y ahora podemos hacer lo que acabo de decir. Ahora vamos a registrar el IEmployeeDataService y su implementación, el EmployeeDataService. Normalmente usaríamos un método que viene con el contenedor de inyección de dependencia, como AddScoped o AddTransient, pero ahora usaremos el método AddHttpClient que, como puede ver aquí, proviene de IHttpClientFactory. Y eso luego inyectará en la clase, el EmployeeDataService en nuestro caso, el HttpClient necesario. Por supuesto, necesitamos ingresar la declaración de uso correcta, y el cliente también está configurado aquí, como puede ver. Estamos especificando que la dirección base del cliente será builder.HostEnvironment.BaseAddress. De hecho, solo tenemos que ir al entorno de alojamiento, que es nuestra API, y usar esa dirección base, por lo que localhost 7039, en mi caso. Así que ahora con el registro en su lugar, volvamos a nuestro EmployeeDataService, y aquí ahora voy a usar la inyección del constructor para inyectar una instancia de HttpClient, y eso proviene de IHttpClientFactory. Entonces, primero, traigamos una instancia de solo lectura de HttpClient, y me gusta el nombre sugerido aquí, y también usemos IntelliSense para crear el constructor. Entonces, como se dijo, esta instancia de HttpClient se inyectará porque nos registramos aquí usando AddHttpClient, por lo que estamos usando el enfoque escrito aquí. Ahora puedo crear las implementaciones de mis métodos. Centrémonos primero en GetAllEmployees. Voy a quitar el tiro aquí, y también voy a hacer esto asíncrono. Traigamos las sentencias using correctas. Aquí vamos. Ahora, ¿qué sucede aquí? Bueno, he usado HttpClient para hacer una solicitud a api/employee. También le pasé algunas opciones para que no distinga entre mayúsculas y minúsculas. Esa respuesta, que será JSON, por supuesto, se deserializará mediante JsonSerializer.DeserializeAsync, y la deserializaremos en un IEnumerable de empleados. Eso significa que traeremos de vuelta a todos los empleados aquí. Hagamos más o menos lo mismo con GetEmployeeDetails, que recibe un employeeId. Así que aquí, ahora haré una solicitud a api/employee/ el id del empleado, y lo deserializaré ahora en un solo empleado. Agregaremos una implementación para agregar, eliminar y actualizar más adelante. Está bien, ya tenemos lista nuestra implementación de nuestro servicio de datos. Volvamos ahora a nuestro componente. Primero vayamos a EmployeeOverview. Muy bien, ahora en el componente, voy a deshacerme de este OnInitialized, que todavía estaba usando MockDataService. Ahora voy a inyectar una instancia de mi IEmployeeDataService. Todavía tenemos que inyectar la inyección de dependencia dentro del componente que usa los atributos Inyectar. No funciona con la inyección de constructor aquí. Tenemos que usar el atributo Inyectar. Así que voy a inyectar aquí un IEmployeeDataService, que registramos con nuestro contenedor de inyección de dependencia aquí, para que mi aplicación lo sepa. Ahora voy a anular OnInitializedAsync. La comunicación con la API se ejecutará de forma asíncrona. También he definido que nuestros métodos son asíncronos, están basados ​​en tareas, así que voy a usar OnInitializedAsync aquí. ¿Qué voy a hacer aquí? Voy a decir ahora que Employees, de hecho, vendrá de invocar todas nuestras instancias de EmployeeDataService que obtenemos a través de la inyección de dependencia, GetAllEmployees. Y eso es esperar que sea una lista, así que llamaremos a ToList. Tendré que hacer los mismos cambios en EmployeeDetail, así que déjame hacerlo rápidamente aquí y mostrarte el resultado. Aquí está el componente EmployeeDetail actualizado. Nuevamente, al atributo Inject, estoy inyectando un IEmployeeDataService, que será un EmployeeDataService, y luego uso para llamar a GetEmployeeDetails, pasando el EmployeeId. Muy bien, es hora del gran momento. Veamos si podemos usar nuestra API desde una aplicación Blazor. Hagamos clic en Empleados. Y ahí vamos, ahora vemos a un empleado, ese es el empleado que regresa de la API. Asegurémonos de que todo siga funcionando, así que vayamos a EmployeeDetail y efectivamente también veremos la página de detalles funcionando. Así que ahora estamos usando datos provenientes de una API.

Administrar el estado de la aplicación

Ahora que nuestra aplicación está actualizada para obtener datos de la API, aprendamos cómo podemos trabajar con el estado de la aplicación. Primero, necesitamos entender de qué se trata el estado de la aplicación. Bueno, déjame explicarte, y lo entenderás en el camino. Si piensa en cómo se ejecuta una aplicación Blazor, en realidad es una aplicación que se ejecuta en la memoria de la máquina. Aunque se ejecuta en el navegador, sigue siendo una aplicación que se ejecuta en la memoria. Si piensa en esto por un minuto, eso significa que aunque cambiemos de página en la aplicación Blazor, la aplicación en sí sigue siendo la misma, y ​​significa que todo lo que está en la memoria permanece en la memoria y se puede acceder a través de las páginas. o componentes. Porque, por otro lado, los componentes en sí mismos son islas. Cada vez que navegamos a un componente, ese componente se vuelve a crear. Con estos dos elementos en mente, ahora veamos y entendamos qué es el estado de la aplicación y para qué se puede usar. En muchos casos, dos o más componentes independientes pueden querer compartir información. Ha visto que los parámetros se pueden usar para pasar datos, pero el estado puede, en muchos casos, ser una solución más flexible. Fíjate en la imagen que ves aquí en la diapositiva. Tengo mi aplicación Blazor. Tengo allí dos componentes, que pueden no estar en pantalla al mismo tiempo. Si el Componente 1 quiere almacenar información para uso posterior de otro componente, puede hacerlo almacenando esos datos, bueno, en la memoria de esa aplicación. Ese dato, cualquiera que sea, es visto como estado. Cómo hacemos eso, lo veremos en un minuto. Pero entonces, el Componente 2 llega a la escena. Quizás el Componente 1 se haya ido y olvidado. Pero como seguimos ejecutando la misma aplicación, por lo tanto, el estado todavía está allí, y el Componente 2 solo puede acceder a ese estado. No hay clases integradas ni ayudantes para trabajar con el estado. De hecho, vamos a tener que confiar en cosas básicas que ya conocemos. Su clase estatal será una clase regular. Lo he llamado aquí ApplicationState. Para cada dato que queramos almacenar, crearemos una propiedad, o incluso un campo. Tenga en cuenta que ApplicationState no es una clase conocida. Es algo que acabo de inventar. Luego, mediante la inserción de dependencias, inyectaremos una instancia de ApplicationState en la colección Services. Y usé para eso, nuevamente, el método AddScoped. Esto da como resultado, por lo tanto, que se registre una instancia de ApplicationState y que ahora sea accesible a través de mi aplicación. UH Huh. Eso es lo que necesitamos. Eso permanece en la memoria. Básicamente, en cualquier parte de mi aplicación ahora puedo hacer uso de esa instancia y los datos almacenados en sus propiedades. Primero, donde queremos trabajar con ApplicationState, inyectaremos la instancia. Ya hemos visto que podemos usar el atributo Inyectar para eso. Siempre va a ser la misma instancia en toda la aplicación que estamos recuperando. Y una vez que tengo el estado de mi aplicación, puedo acceder a sus datos a través de sus propiedades. Ahora podemos, usando el estado, compartir datos entre componentes que no se conocen entre sí, por lo tanto, sin el estado de los parámetros. Los datos están vinculados, digamos, a la instancia de la aplicación. Está en la memoria. Pero también significa que cuando se reinicia la aplicación, los datos ya almacenados desaparecen. Significa que se reconstruirá la colección de servicios. Solo presionar F5 ya lo hará. Todavía no hay una persistencia real.

Demostración: Compartir estado entre componentes

Es hora de volver a Visual Studio y ver cómo podemos hacer que dos componentes funcionen con el estado. Ahora ya sabe mucho más sobre la inyección de dependencia y lo usaremos para trabajar con el estado. De hecho, permitiremos que dos componentes, que no están anidados en este caso, hablen entre sí a través de un espacio de memoria compartida, digamos. Les permitiremos trabajar con los mismos datos, y esos datos son el estado de la aplicación. De hecho, podemos guardar lo que queramos en el estado de la aplicación y usarlo desde otro componente. Eso es lo que quiero hacer aquí. Le mostraré el estado de la aplicación usando uno de los widgets que se muestran dinámicamente aquí en la página de inicio. Ahora vemos aquí que actualmente tenemos nueve preguntas. Recuerde, ese fue un valor aleatorio, pero tal vez necesite ese valor en algún otro lugar de mi aplicación. Tal vez otro componente también necesite acceso a eso. Ahora, eso no es posible. Definitivamente si no es un componente anidado. Lo resolveré con el estado de la aplicación. Entonces, lo que haré es crear una clase ApplicationState. Nuevamente, Blazor no conoce el estado de la aplicación. Es solo una clase. Le daré el nombre ApplicationState, pero puedes ponerle el nombre que quieras y lo pondré en la raíz de la aplicación. Así que agregaré una nueva clase y la llamaré ApplicationState. Aquí, agregaré todas las propiedades de estado de mi aplicación. Por ejemplo, esa cantidad de mensajes podría ser un valor de estado, así que agréguelo aquí. Agregaré NumberOfMessages como propiedad en ApplicationState. Ahora, para hacer este nodo dentro de mi aplicación, regresaré al programa, y registraré una instancia de este ApplicationState con mi contenedor de inyección de dependencia. El contenedor de inyección de dependencia, solo hay una instancia de eso. Y si me registro en la colección de Servicios para AddScoped una instancia del estado de la aplicación, esa instancia del estado de la aplicación, que luego se inyectará en el contenedor de inyección de dependencia, se puede recuperar para lo que queramos en la aplicación. Entonces, a través de múltiples componentes. Así que registro aquí que quiero que ApplicationState se registre de manera limitada. Se creará una instancia. Podríamos haber usado AddSingleton aquí, eso habría tenido el mismo resultado. De hecho, solo hay una instancia para la aplicación en ejecución que se está creando. Déjame hacer ahora lo que acabo de decir. Voy a crear un nuevo componente. Llamémoslo InboxCounter como un nuevo componente que también necesita acceso a esa cantidad de mensajes. Así que crearé un nuevo componente de Razor y lo llamaré InboxCounter y, por supuesto, agregaremos una clase de back-end. En la interfaz de usuario, solo voy a mostrar el valor de MessageCount. Ese es el campo que aún necesito crear en mi clase de back-end. Así que aquí está MessageCount, que es un activo para un valor aleatorio. Ahora, MessageCount es un valor aleatorio, pero no puedo acceder a él dentro de los widgets, por ejemplo. Resolvamos eso usando ApplicationState. Voy a, de nuevo a través de la inyección de dependencia, por lo que usando el atributo Inyectar, inyecte una instancia del estado de la aplicación. Solo había una instancia en toda la aplicación, por lo que ahora puedo decir que ApplicationState.NumberOfMessages, esa era la propiedad, es igual a MessageCount. Ahora este componente establece el valor dentro de ApplicationState. Ahora necesito acceder a este valor en otro componente, el widget de la bandeja de entrada. En lugar de hacer que esto también calcule el valor aleatorio, le permitiremos acceder a ese valor de ApplicationState. Entonces, inyectaremos aquí también ApplicationState que es la misma instancia de ApplicationState, y aquí en el no inicializado, ya no lo convertiré en un número aleatorio, sino que obtendré el valor de MessageCount de ApplicationState número de mensajes. Quiero mostrarles que estos dos componentes, que no se conocen, en realidad pueden mostrar el mismo valor. Así que voy a ir a mi diseño principal, y aquí agregaré InboxCounter. Si ahora volvemos a ejecutar la aplicación, veremos que se muestra el mismo valor tanto en la página de índice como en la barra de navegación. Aquí vamos. Aquí dice que tenemos seis preguntas y también aquí en la parte superior, vemos que regresan los seis mensajes. Estos dos componentes están leyendo los mismos datos, y los datos se almacenan instantáneamente y se pueden usar prácticamente en todas partes dentro de mi aplicación.

Almacenamiento de datos localmente

El estado de la aplicación puede ayudar a que los componentes puedan compartir datos, pero como se dijo, esos datos están en la memoria y se perderán una vez que actualicemos la aplicación. Ahora agreguemos otra capa de trabajo con datos y almacenamiento de datos localmente. Antes de ver cómo podemos almacenar cualquier dato de forma persistente, aprendamos sobre un problema que podemos tener con nuestra aplicación. Digamos que en nuestra aplicación Blazor, tenemos la descripción general de los empleados y los detalles de los empleados. Un usuario que esté trabajando con la aplicación primero navegará a la descripción general. Eso activará una solicitud HTTP GET que se enviará a la API para recuperar a todos los empleados. Luego, navegan a la página de detalles de un empleado con ID 3. Se realiza una nueva llamada a la API para recuperar esos detalles. A continuación, el usuario vuelve a la descripción general y, de nuevo, se inicia otra llamada a la API para obtener a todos los empleados. Ese es el mismo que hemos hecho hace unos segundos. ¿No estamos enfatizando la API de esta manera? ¿Qué pasa si nosotros, cuando recuperamos la lista de empleados por primera vez, la almacenamos localmente? Luego seguimos yendo a la API para obtener los detalles, pero cuando lleguemos nuevamente a la página de descripción general, obtendremos los datos de la tienda local. Sí, funciona un poco como un caché y, por supuesto, necesitaremos una forma de asegurarnos de que los datos no estén obsoletos. Pero la idea general aquí es que podemos almacenar datos localmente y así reducir la cantidad de llamadas a nuestra API. Almacenar datos en el navegador no es algo de Blazor, es una API de navegador que viene con los navegadores modernos. En aplicaciones web regulares, podemos usar JavaScript para interactuar con este almacenamiento de datos. Se conoce como SessionStorage y LocalStorage. LocalStorage es realmente un almacenamiento persistente dentro del navegador y está vinculado a un dominio. Esos datos son persistentes y, por lo tanto, incluso después de cerrar el navegador, esos datos siguen ahí. También se comparte entre pestañas o ventanas, siempre que esté trabajando con una aplicación en un dominio determinado. SessionStorage, por otro lado, tiene una vida más corta. También nos permitirá almacenar datos, pero los datos se borran cuando finaliza la sesión del navegador. Eso significa que después de reiniciar el navegador, los datos desaparecerán. Esto puede ser lo que desea, de hecho, por razones de seguridad. La buena noticia es que esto también se puede usar desde Blazor. No es un lugar nativo para presentar, pero Blazor puede hablar con JavaScript y podemos acceder al almacenamiento local y de sesión. Veremos en un módulo posterior cómo podemos interoperar manualmente con JavaScript para realizar ciertas funcionalidades. Sin embargo, algunos populares, como LocalStorage, tienen sido envuelto en paquetes que podemos usar directamente. Bajo las sábanas, se usa JavaScript, pero ni siquiera nos damos cuenta. El paquete Blazored LocalStorage es un paquete muy útil que nos permite almacenar datos y recuperarlos más adelante. Como con casi todo, antes de comenzar a usar este paquete, debemos registrarlo en la colección de Servicios. Voy a mostrar esto en la demostración. Una vez que se hace a través de la inyección de dependencia, podemos inyectar una instancia de ILocalStorageService, que tiene métodos para almacenar y leer datos. En la diapositiva aquí, veremos que vamos a intentar recuperar una cadena usando GetItemAsync, pasando la clave. Entonces, EmployeeFirstName. En este caso, estamos recuperando una cadena, pero recuerde lo que dije antes sobre la reducción de las llamadas a la API. De hecho, podemos, utilizando exactamente el mismo enfoque, almacenar los datos devueltos por la API en LocalStorage para su uso posterior. Incluso podemos añadir como un tiempo de caducidad. Y cuando eso termine, buscaremos nuevos datos de la API y los almacenaremos nuevamente. Eso es, de hecho, lo que haremos en la próxima demostración. Para trabajar con LocalStorage, hay algunas API integradas. SetItem y la versión asíncrona, SetItemAsync, nos permiten almacenar un valor en LocalStorage. Se le asignará una clave para luego poder recuperarla. La obtención del valor en función de la clave se realiza mediante GetItem y GetItemAsync, y también hay una forma de comprobar la presencia de una clave. Para eso, usamos ContainKey y ContainKeyAsync, y es posible eliminar un elemento usando sorpresa, sorpresa, RemoveItem y RemoveItemAsync. buscaremos nuevos datos de la API y los almacenaremos nuevamente. Eso es, de hecho, lo que haremos en la próxima demostración. Para trabajar con LocalStorage, hay algunas API integradas. SetItem y la versión asíncrona, SetItemAsync, nos permiten almacenar un valor en LocalStorage. Se le asignará una clave para luego poder recuperarla. La obtención del valor en función de la clave se realiza mediante GetItem y GetItemAsync, y también hay una forma de comprobar la presencia de una clave. Para eso, usamos ContainKey y ContainKeyAsync, y es posible eliminar un elemento usando sorpresa, sorpresa, RemoveItem y RemoveItemAsync. buscaremos nuevos datos de la API y los almacenaremos nuevamente. Eso es, de hecho, lo que haremos en la próxima demostración. Para trabajar con LocalStorage, hay algunas API integradas. SetItem y la versión asíncrona, SetItemAsync, nos permiten almacenar un valor en LocalStorage. Se le asignará una clave para luego poder recuperarla. La obtención del valor en función de la clave se realiza mediante GetItem y GetItemAsync, y también hay una forma de verificar la presencia de una clave. Para eso, usamos ContainKey y ContainKeyAsync, y es posible eliminar un elemento usando sorpresa, sorpresa, RemoveItem y RemoveItemAsync. Se le asignará una clave para luego poder recuperarla. La obtención del valor en función de la clave se realiza mediante GetItem y GetItemAsync, y también hay una forma de comprobar la presencia de una clave. Para eso, usamos ContainKey y ContainKeyAsync, y es posible eliminar un elemento usando sorpresa, sorpresa, RemoveItem y RemoveItemAsync. Se le asignará una clave para luego poder recuperarla. La obtención del valor en función de la clave se realiza mediante GetItem y GetItemAsync, y también hay una forma de comprobar la presencia de una clave. Para eso, usamos ContainKey y ContainKeyAsync, y es posible eliminar un elemento usando sorpresa, sorpresa, RemoveItem y RemoveItemAsync.

Demostración: Almacenamiento de datos en LocalStorage

Es hora de ver esto de una manera práctica. Primero incorporaremos el paquete Blazored.LocalStorage y luego haremos que el servicio de cliente de la API sea más inteligente, para que vea si ya tenemos los datos disponibles localmente. Cuando en nuestra aplicación navegamos desde la Descripción general a los Detalles y viceversa, cada vez que se realiza una llamada a la API. Debido a que el componente Overview básicamente se está recreando, también llegará a la API. En realidad, eso puede ser una gran carga para la API. Crea bastante carga, así que lo que voy a hacer es crear una forma de almacenamiento en caché para que el servicio de datos almacene los datos localmente y solo se actualice cuando sea necesario o después de un cierto período de tiempo. También podríamos hacer esto con el estado, como vimos en la demostración anterior, pero ahora voy a aprovechar esta oportunidad para mostrarles también cómo podemos hacer que estos datos sean persistentes. Tal vez queramos almacenarlo durante más tiempo, incluso entre reinicios de aplicaciones, y luego podemos usar el almacenamiento local. Déjame enseñarte como. Ahora, trabajar con el almacenamiento local del navegador se puede hacer completamente de forma manual. Podemos usar la interoperabilidad de JavaScript para hacer esto, pero en su lugar usaré un paquete, el paquete Blazored.LocalStorage y que ya nos brinda esta funcionalidad, y podemos simplemente llamar a su API. Así que voy a ir a mi archivo csproj nuevamente y agregaré el paquete Blazored.LocalStorage. Guarde esto y ese paquete se descargará. Este paquete, como ya vimos en las diapositivas, me brinda la capacidad de almacenar datos localmente en el almacenamiento local del navegador o en el almacenamiento de la sesión. Podemos recuperar elementos, agregar elementos, ver si están allí, y así sucesivamente. Antes de hacer eso, antes de interactuar, de hecho, con este paquete, necesitaremos hacer un registro en el programa. Entonces, en la colección de Servicios, tendré que brindar soporte para el paquete llamando a builder.Services.AddBlazoredLocalStorage. Obtenemos un ondulado rojo, y podemos resolverlo trayendo, por supuesto, la declaración de uso correcta. Entonces, lo que haré ahora es ir a mi EmployeeDataService y mejorarlo con almacenamiento local. Traeremos una instancia de ILocalStorageService que, de hecho, también proviene de Blazored.LocalStorage, y se ejecutará a través de la inyección de dependencia, por lo que agregaremos otro parámetro de constructor aquí. Ahora, nuevamente, la inyección de dependencia y la inyección de constructor inyectarán una instancia de ILocalStorageService, una instancia que implementa esa interfaz, por supuesto. Entonces, lo que haré ahora es almacenar mis datos localmente. Voy a crear una forma de almacenamiento en caché. Verificaré si los datos ya están allí, y si están allí, si no están obsoletos. Si es demasiado antiguo, me comunicaré con mi API nuevamente y obtendré nuevos datos, y los almacenaré también en el almacenamiento local. Voy a pegar ese flujo y mostrarles el resultado. El refreshRequired será falso por defecto. Entonces, si refreshRequired es falso, usaremos este bloque. Primero compruebo si se puede encontrar una ExpirationKey de empleado. De hecho, agregué esta clase LocalStorageConstants, que contiene las claves. Son solo cadenas para mi almacenamiento local. Si existe una ExpirationKey, entonces este código se ejecutará. Y voy a verificar si el DayTime que está almacenado allí es mayor que la hora actual. Eso significaría que el artículo aún no ha caducado. Si podemos encontrar los datos con esta clave aquí, EmployeesList, entonces los recuperaremos del almacenamiento local usando GetItemAsync, pasando ListKey nuevamente y devolviendo los datos como una lista de empleados. Sin embargo, si se requiere la actualización o los datos ya han caducado o no se pueden encontrar, entonces ejecutaremos este código. Haremos una llamada nuevamente a api/employee como lo hicimos antes, y la almacenaremos en una lista. Es decir, en este caso, un IEnumerable de Empleados. Y antes de devolver esos datos, los almacenaremos en el almacenamiento local llamando a SetItemAsync dos veces, de hecho. Almacenaremos los datos y también almacenaremos el tiempo de caducidad, que he establecido dentro de un minuto. De esta forma, mientras los datos no hayan caducado,

Resumen

Nuevamente, otro módulo realmente útil hecho. Hemos visto que necesitaremos interactuar con las API para recuperar datos remotos actualizados en nuestra aplicación. La clase más importante en esta área es HttpClient, y hemos visto cómo usamos IHttpClientFactory. Finalmente, hemos visto formas de almacenar datos localmente, tanto como estado, como datos persistentes en el almacenamiento local del navegador. Ahora hemos mostrado principalmente datos. Tiempo para permitir que el usuario ingrese datos a través del uso de un formulario.