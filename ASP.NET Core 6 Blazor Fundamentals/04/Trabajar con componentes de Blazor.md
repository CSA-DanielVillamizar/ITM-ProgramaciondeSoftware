# Trabajar con componentes de Blazor

Cátedra Programación de Software y Programática - Fundamentos de ASP.NET Core 6 Blazor

**Introducción al módulo**

Los componentes son la piedra angular de cualquier aplicación de Blazor y, de hecho, a lo largo de todo este curso, trabajamos constantemente con ellos de una forma u otra. Hay mucho más que aprender sobre los conceptos fundamentales en torno a los componentes, y he decidido incluir otro módulo bastante extenso sobre componentes, y está a punto de comenzar a verlo. Veamos lo que he incluido en este módulo. Primero, veremos cómo trabajar con datos y componentes, incluidos temas como los parámetros. A continuación, incorporaremos la navegación a nuestra aplicación. Dado que la aplicación se compone de componentes, la navegación también es un componente. Le mostraré RenderFragment, así como también cómo cargar componentes dinámicamente. Como no somos perfectos, los componentes también contendrán errores, y la experiencia predeterminada para ver qué salió mal con el componente en Blazor no siempre es muy útil. También le mostraré cómo podemos mejorar esto. Y finalmente, comenzaremos a explorar el conjunto de componentes integrados. Veremos bastantes más en esta área en los próximos módulos. Todos estos temas, los aplicaremos directamente en nuestra aplicación para mejorarla y agregar funcionalidad adicional. Entonces, al final de este módulo, Bethany's Pie Shop HRM ya incluirá muchas más funciones. Sumerjámonos. aplicaremos directamente en nuestra aplicación para mejorarla realmente y agregar funcionalidad adicional. Entonces, al final de este módulo, Bethany's Pie Shop HRM ya incluirá muchas más funciones. Sumerjámonos. aplicaremos directamente en nuestra aplicación para mejorarla realmente y agregar funcionalidad adicional. Entonces, al final de este módulo, Bethany's Pie Shop HRM ya incluirá muchas más funciones. Sumerjámonos.
	

**Hacer más con los componentes**

Y empecemos, bueno, haciendo más con los componentes. Presentaré algunos temas centrales sobre los componentes y luego los aplicaremos en nuestra aplicación en la próxima demostración. Hemos visto en el módulo anterior que crearemos componentes mediante la creación de una interfaz de usuario en el archivo razor y la lógica en una clase de componente. Así es al menos como hago las cosas en mis proyectos. Razor a menudo se usará para crear aplicaciones basadas en datos, por lo que a menudo necesitaremos mostrar datos en nuestro código de interfaz de usuario. La visualización de datos se puede hacer, como podemos ver aquí en esta diapositiva. A la izquierda, podemos ver la interfaz de usuario de razor y, a la derecha, vemos la clase de componente de respaldo, por lo que EmployeeDetail.razor.cs. Digamos que en el código tengo dos propiedades públicas, FirstName y LastName, y quiero mostrarlas en la interfaz de usuario. En el código de afeitar, ahora puedo hacer exactamente eso usando @FirstName y @LastName. Al usar el signo @, razor sabe que viene el código y simplemente podemos invocar las propiedades aquí. En tiempo de ejecución, los valores de estas propiedades se mostrarán aquí en la interfaz de usuario. Técnicamente, esta es una forma de enlace de datos. Los datos de la clase de código subyacente están enlazados en la interfaz de usuario en un modo unidireccional, es decir, desde el origen, la clase, la interfaz de usuario y el código de afeitar. ¿Qué pasa si queremos mostrar campos privados de la clase del componente? Como puede ver aquí, ahora tengo dos campos privados definidos en la clase de componente y estoy usando, bueno, el mismo enfoque para mostrarlos en la interfaz de usuario. ¿Esto funciona? Bueno, la respuesta es sí. Dado que la clase del componente es una clase parcial con una clase generada a partir del componente, también podemos usar este enfoque. Digamos que ahora tenemos un objeto complejo. Digamos, empleado, del cual tenemos una instancia en la clase de componente. Eso es lo que vemos aquí a la derecha. Luego, también podemos, en el código de afeitar, apuntar a la instancia de Employee para mostrar sus datos. He hecho exactamente eso aquí agregando Employee.FirstName y Employee.LastName. Puntear en las propiedades, pero también incluir llamadas a métodos, como ToString, se puede incluir en el código de afeitar para ajustar cómo se usarán los datos. Ya hemos hecho esto, pero quiero señalarlo aquí de nuevo. El anidamiento de componentes es muy común. Para ser claros, anidar componentes es usar un componente dentro de otro componente. El anidamiento es algo que hacemos en el código declarativo, por lo que en el código de marcado HTML. Y como dije, ya lo has hecho, tal vez incluso sin darte cuenta. Digamos que tenemos un componente que creamos en el que solo mostramos un título. Este componente está en un archivo llamado PageHeader.razor. Por lo tanto, el componente se llama PageHeader. Ahora podemos usar este componente en nuestro componente EmployeeOverview. EmployeeOverview era un componente de página, por lo que un componente que llenaba la pantalla, podemos navegar hasta él. Pero, aún así, es un componente y puedo incluir el componente PageHeader dentro de él. Incluir un componente dentro de otro componente es anidar componentes. Y sí, ya lo hemos hecho varias veces en el módulo anterior sin pensarlo demasiado. Otro concepto que aún no hemos analizado es el espacio de nombres en el que vive un componente. El espacio de nombres será importante cuando hagamos referencia a componentes en un espacio de nombres y, si viven en otro espacio de nombres, entonces tendremos que hacer referencia a ese espacio de nombres, al igual que en las aplicaciones regulares de .NET. Existe una forma predeterminada de determinar el espacio de nombres de un componente, en función de dónde coloquemos el componente. En primer lugar, toda la aplicación tendrá un espacio de nombres raíz, que suele ser el nombre del proyecto. Luego, cuando colocamos un componente en una subcarpeta, también se agrega, se anida si es necesario. Entonces, el espacio de nombres completo se convierte en el espacio de nombres raíz más la carpeta, separados por un punto. Cuando desee usar un componente en un determinado espacio de nombres dentro de otro componente que vive en un espacio de nombres diferente, debemos hacer referencia a ese espacio de nombres usando @using. En lugar de agregar una declaración de uso en el componente real, también podemos usar el archivo _Imports.razor. Ese archivo fue generado por la plantilla del proyecto y se puede usar para traer espacios de nombres que estarán disponibles para todos los componentes de razor, evitando efectivamente que agreguemos estos en todos los componentes que creamos. De forma predeterminada, este archivo ya contiene una cantidad de espacios de nombres necesarios para que Blazor use algunas directivas @using. Podemos agregar el nuestro aquí, como podemos ver en la parte inferior, y eso traerá el espacio de nombres BethanysPieShopHRM.App.Components, de modo que los componentes en este espacio de nombres también se puedan usar en otros componentes. Aquí hay un ejemplo. Digamos que tenemos un componente en la carpeta Componentes. El espacio de nombres del que formará parte ese componente es el espacio de nombres raíz más la carpeta. Entonces, si nuestra aplicación se llama BethanysPieShopHRM.App, también se convierte en el espacio de nombres raíz. Si luego colocamos el componente EmployeeCard en la carpeta Componentes, el espacio de nombres completo se convierte en BethanysPieShopHRM.App.Components. Si ahora queremos usar este componente dentro de otro componente que vive en un espacio de nombres diferente, entonces debemos usar la directiva @using, seguida de BethanysPieShopHRM.App.Components. Antes de ir a la demostración, donde crearemos el componente EmployeeCard, quiero presentarle los parámetros del componente. Hasta ahora, nuestro componente, EmployeeOverview, era un componente de relleno de página, y a menudo se los denomina componentes de página. Sin embargo, muchos componentes no llenarán la página y solo los usaremos de forma anidada, es decir, desde un componente principal. En esa perspectiva, puede ser que el componente principal quiera pasar datos al componente anidado, al componente secundario, y para hacerlo, para pasar datos entre componentes, podemos pasar parámetros. Los parámetros se definen como propiedades públicas en el componente que recibe los datos. Para que estas propiedades se conviertan en un parámetro, deben estar decoradas con el atributo Parámetro. Las propiedades de los parámetros pueden ser tipos simples, como números enteros o cadenas, pero también es posible pasar un tipo complejo, por ejemplo, como una instancia de empleado. Aquí vemos un componente, muy básico, que puede aceptar un parámetro, Nombre, de tipo cadena. El nombre es de hecho una propiedad pública, por lo que ya es bueno. Luego, también hemos decorado una propiedad con el atributo Parámetro. Ahora bien, este es un parámetro que podemos usar para pasar datos a este componente. Podemos usar la propiedad de parámetro como una propiedad normal, por ejemplo, aquí podemos ver que mostramos en este caso el Nombre en la interfaz de usuario del componente. Cuando ahora queremos invocar este componente desde otro componente, podemos pasar datos al componente. Si el componente se llama EmployeeCard y define una propiedad Name, podemos simplemente, usando un atributo aquí, pasar datos al parámetro Name. Y al usar Visual Studio, también obtendremos IntelliSense en esta propiedad.

**Demostración: trabajar con parámetros de componentes**

Muy bien, ya hemos tocado varios temas. Así que ahora quiero regresar a Visual Studio y poner esto en práctica. Crearemos un nuevo componente, el componente EmployeeCard, y lo usaremos para mostrar el empleado. Hasta ahora, hemos usado solo una tabla, que giraba sobre los empleados y los mostraba, bueno, dentro de una tabla. Ahora comenzaremos a usar un componente separado y lo mostraremos en la cuadrícula, y este componente también será parte del espacio de nombres. La tarjeta también necesitará obtener datos, por lo que usaremos un parámetro para pasarle datos. En este punto, nuestros empleados están representados con esta tabla que creamos en el módulo anterior. Ahora bien, aunque eso se ve bien, hay formas más agradables de representar a cada empleado. Voy a introducir un nuevo componente para representar a cada empleado. Voy a crear el llamado componente EmployeeCard que tiene una imagen más grande, y luego también agregaremos algunos botones de acción en esa tarjeta en las próximas demostraciones. Así que vamos a crear ese componente EmployeeCard. Ahora, el componente que creamos en el último módulo fue EmployeeOverview, y en realidad era un componente de página. Ahora voy a crear un componente que no llene la pantalla. Así que no lo voy a poner dentro de la carpeta Páginas. Voy a crear la carpeta Componentes, y esa suele ser la convención que uso. Los componentes de relleno de página se colocan en la carpeta Páginas y los componentes que no son de relleno de página, por lo que los componentes más pequeños normalmente los coloco dentro de la carpeta Componentes. Primero creemos esa carpeta. Aquí, voy a crear el componente EmployeeCard, así que haré clic derecho y luego diré Add Razor Component, y llamaré a EmployeeCard. Nuevamente, crearemos una clase de respaldo, o clase de componente, y esa será la clase normal. Lo llamo EmployeeCard, por lo que el mismo nombre, .razor.cs. Y nuevamente, si Visual Studio comienza a quejarse por el hecho de que ahora tenemos dos clases con el mismo nombre, entonces agrego parcial aquí y luego todos están contentos nuevamente. ¿Qué hará esta tarjeta de empleado? Bueno, representará a un solo empleado. Ese empleado único que voy a envolver dentro de una propiedad, y será la propiedad del Empleado. Este empleado lo voy a usar para crear mi interfaz de usuario. Así que voy a ir a la interfaz de usuario del componente de mi tarjeta, eliminaré el código que se genera de forma predeterminada y agregaré un poco más de código yo mismo. Primero, presentaré los diseños que consisten en un par de divisiones anidadas, y aquí, en ese h4, voy a mostrar el nombre del empleado. El empleado se representa con esta propiedad Empleado. Así que ahora puedo decir que quiero mostrar aquí @Employee.FirstName, y un espacio, y luego @Employee.LastName, por supuesto, nuevamente sin olvidar el signo @ para asegurarme de que Razor entienda que estamos escribiendo código aquí. Entonces, dentro del código Razor, también podemos puntear en las propiedades de la propiedad Employee. Estoy en el cuerpo de la tarjeta, voy a mostrar también una imagen, una imagen más grande que tiene su fuente nuevamente a través de una concatenación de cadenas donde se usa el EmployeeId del empleado. Tenga en cuenta que no uso @Employee para EmployeeId aquí, porque ya tenía el signo @ aquí. Nuevamente, estamos usando algunas de esas imágenes codificadas. Volveremos a eso más adelante. Ahora, por supuesto, necesitamos obtener de alguna manera este valor de este empleado dentro de esta tarjeta de empleado. Necesitamos conectar ese valor, necesitamos pasarle sus datos, o la EmployeeCard no se usará de forma independiente, por lo que la usaremos en combinación con un componente principal, y ese componente principal se va a para pasar datos a esta tarjeta de empleado. Puedo pasar datos a un componente anidado usando el atributo Parámetro. Al convertir esto en un parámetro, puedo usar este componente y pasarle un valor, en este caso, un empleado. Voy a traer las declaraciones de uso correctas para eso, y ahora esta propiedad de Empleado de la Tarjeta de Empleado puede recibir un valor cuando usamos el componente Tarjeta de Empleado. Ahora hagamos eso. Volvamos a EmployeeOverview y usemos efectivamente nuestro componente. Ahora hasta ahora, hemos usado esta tabla que recorrí los empleados y creé una nueva fila. Voy a eliminar eso y voy a usar una nueva forma de crear el diseño. Y traje una fila de clase div, eso es nuevamente una cosa de Bootstrap que colocará mis tarjetas una al lado de la otra hasta que la fila esté llena. Y luego allí, tengo nuevamente un foreach que contendrá otro div en el que ahora voy a usar mi EmployeeCard. Si empiezo a escribir aquí, EmployeeCard, como hicimos antes con el contador, todavía no encontraremos EmployeeCard. Es porque EmployeeCard vive en un espacio de nombres diferente, en BethanysPieShop.HRM.App.Components. Ahora bien, si no quiero traer esa declaración de uso por todas partes, voy a ir a mi archivo de Importaciones, y voy a agregar aquí otra declaración de uso, trayendo ese espacio de nombres específico. Ahora, por lo general, necesitará hacer una compilación, y cuando regrese a su EmployeeOverview y ahora haga EmployeeCard, IntelliSense encontrará esa EmployeeCard. Hay una cosa más que tenemos que hacer. Necesitamos también pasarle ese valor de parámetro. Definimos una propiedad llamada Empleado con un atributo de parámetro en el HTML, por lo que en el código de marcado de la tarjeta de empleado. Ahora podemos decir que Empleado es igual a este Empleado. Estamos pasando este Empleado a la Tarjeta de Empleado y eso puede visualizarlo. Creo que estamos bien. Ya hemos utilizado la EmployeeCard. Ejecutemos la aplicación y veamos si todo parece correcto. Hagamos clic en Empleados, y ahí vamos. Nuestros empleados ahora están representados mediante un nuevo componente, la EmployeeCard.

**Eventos en componentes y ciclo de vida de los componentes**

Nuestros componentes hasta ahora solo eran capaces de mostrar la fecha y todavía no es posible interactuar con ellos. Por lo general, querremos una forma de hacer clic en un botón y activar el código en un componente. Eso es, por supuesto, nada especial. Será un evento y un controlador de eventos que necesitaremos incluir. En Blazor, podemos hacerlo usando una sintaxis simple. En general, usaremos @on, luego el nombre del evento DOM, por ejemplo, haga clic en, y luego el controlador de eventos delegado. Este último apunta al código en el código C#, por lo tanto, en la clase de componente. Aquí hay un ejemplo. Digamos que queremos escuchar por un clic en el botón. En HTML, hay un evento DOM llamado clic, por lo que podemos usar @onclick. Como valor, luego pasamos el nombre del controlador de eventos en el código, y está aquí, SaveEmployee. En el código C#, luego necesitamos incluir un controlador de eventos donde podamos, en este caso, incluir código para guardar un empleado actualizado. Una cosa importante a tener en cuenta aquí es que cuando se activa un evento y, por lo tanto, se ejecuta el código, Blazor buscará cualquier cambio en el estado y se actualizará en consecuencia sin que tengamos que hacer nada aquí. Eso significa que si dentro del controlador de eventos, actualizamos el valor de la propiedad y esa propiedad se muestra en la interfaz de usuario, este valor modificado se actualizará automáticamente para nosotros. No es necesario hacer ninguna actualización manual. El código de la diapositiva anterior no usaba ningún parámetro y, muy a menudo, no será necesario. Sin embargo, para algunos eventos, a saber, los que admiten un tipo de argumento de evento, podemos especificar un parámetro en el controlador. Este último se rellenará automáticamente. Aquí puedes ver un ejemplo de uno que soporta esto, el evento de clic. No se cambia nada en el código de Razor. Sin embargo, en el controlador de eventos, ahora he incluido un parámetro MouseEventArgs. Eso se pasa automáticamente, y podríamos usarlo para obtener acceso a las coordenadas de donde ocurrió el clic. Otro evento que usa esto es onkeydown, que pasa KeyboardEventArgs, brindándonos información sobre la tecla o combinación de teclas usada. Nuevamente, en la mayoría de los casos, no necesitaremos ningún parámetro adicional. Pero supongamos que tenemos varios botones generados dinámicamente y necesitamos averiguar en qué botón se hizo clic. Luego, necesitaremos incorporar un parámetro adicional en el método de manejo de eventos, y cuando queramos invocarlo ahora, debemos usar una sintaxis diferente, es decir, usar expresiones lambda. Primero, en el controlador de eventos, ahora podemos ver que ahora está esperando un parámetro entero adicional. En el código de Razor, ahora necesitaremos especificar un valor para esto y, como se dijo, debemos confiar en la sintaxis de expresiones lambda para hacerlo. El código aquí pasará dos valores, el MouseEventArgs nuevamente, pero luego, en segundo lugar, el buttonNumber. Y este último se definió como una variable dentro del ciclo for. Cuando usamos componentes primarios y secundarios, ya hemos visto que podemos pasar datos del componente primario al secundario usando uno o más parámetros. Relacionado con esto, también es posible activar la ejecución de código en el padre cuando ocurre un evento hijo. Digamos que tenemos, como podemos ver aquí, un componente principal y uno secundario, y cuando ocurre un evento en el elemento secundario, como un clic en el botón, queremos activar el código en el elemento principal. Eso es posible usando lo que se conoce como EventCallback. En este caso, el componente principal puede asignar un método a EventCallback del componente secundario. Veamos cómo podemos hacer esto. Primero, el componente hijo. Allí, definimos una propiedad de tipo EventCallback y notamos que esto también recibe el atributo de parámetro, lo que significa que puede conectarse desde el padre que declara este componente. Lo que vamos a pasar, en este caso, es el delegado definido en el padre. Ahora estamos en el componente secundario. Se activa @onclick, se invocará el método definido en el padre. Aquí ahora estamos creando el ChildComponent a partir del código principal. Para la propiedad EventCallback denominada TriggerCallbackToParent, he definido un delegado de controlador de eventos en el código del padre, y ese es el ShowPopup. Entonces, de hecho, cuando ahora el evento se active en ChildComponent, se ejecutará el código en el padre. Antes de regresar y comenzar a aplicar todo esto y más en una demostración, quiero discutir otro tema importante que ya está parcialmente aquí, a saber, el ciclo de vida del componente. Primero, ¿cuál es el ciclo de vida del componente? Bueno, gran pregunta. Los componentes de Razor pasarán por una serie de pasos antes de que podamos interactuar con ellos y, en momentos específicos, se activará un evento. Podemos adjuntar código a estos eventos, brindándonos efectivamente la capacidad de conectar estos métodos y activar, por lo tanto, nuestro propio código en puntos específicos en el tiempo. Hay bastantes opciones a las que podemos conectarnos, y veremos algunas con más detalle más adelante en el curso. Algunos eventos del ciclo de vida tienen un objetivo muy específico, y veremos más que eso más adelante. Comencemos con una breve descripción de los más importantes aquí. El que probablemente usará más es OnInitialized o su hermano asíncrono, OnInitializedAsync. Como el nombre se revela, estos se llaman cuando se inicializa el componente. En estos métodos, normalmente haremos la configuración de los datos necesarios para un componente. Cuando usamos una API en el siguiente módulo, la llamada a la API para datos reales ocurrirá en este mismo método. Los valores iniciales para cualquier parámetro ya estarán disponibles en este punto. A continuación, tenemos OnParametersSet, así como OnParametersSetAsync. Esto se invocará después de OnInitialized cuando se reciban nuevos valores para los parámetros. A veces, los componentes obtendrán nuevos valores y, en ese caso, se llamará a estos métodos. Finalmente, están OnAfterRender y OnAfterRenderAsync. Nuevamente, como el nombre revela, esto se llamará bastante tarde en el ciclo, básicamente cuando el componente ha terminado de renderizarse. Entonces, en este punto, el componente está listo. ha sido creado Sin embargo, cuando sea necesario interactuar con cualquier código JavaScript, lo haremos aquí. Cuando veamos la interoperabilidad de JavaScript más adelante en el curso, veremos que estos métodos se usan para la configuración. Interactuar con estos métodos no es muy complejo, como podemos ver aquí. Estos métodos se definen en las clases de componentes base de las que heredan nuestros componentes. Entonces, supongamos que desea agregar código a OnInitialized para realizar una inicialización adicional en nuestro componente, entonces simplemente podemos crear una anulación, en este caso, para OnInitialized. Comenzaremos a hacer esto muy pronto, y sí, lo haremos en casi todos los componentes que creemos. ha sido creado Sin embargo, cuando sea necesario interactuar con cualquier código JavaScript, lo haremos aquí. Cuando veamos la interoperabilidad de JavaScript más adelante en el curso, veremos que estos métodos se usan para la configuración. Interactuar con estos métodos no es muy complejo, como podemos ver aquí. Estos métodos se definen en las clases de componentes base de las que heredan nuestros componentes. Entonces, supongamos que desea agregar código a OnInitialized para realizar una inicialización adicional en nuestro componente, entonces simplemente podemos crear una anulación, en este caso, para OnInitialized. Comenzaremos a hacer esto muy pronto, y sí, lo haremos en casi todos los componentes que creemos. ha sido creado Sin embargo, cuando sea necesario interactuar con cualquier código JavaScript, lo haremos aquí. Cuando veamos la interoperabilidad de JavaScript más adelante en el curso, veremos que estos métodos se usan para la configuración. Interactuar con estos métodos no es muy complejo, como podemos ver aquí. Estos métodos se definen en las clases de componentes base de las que heredan nuestros componentes. Entonces, supongamos que desea agregar código a OnInitialized para realizar una inicialización adicional en nuestro componente, entonces simplemente podemos crear una anulación, en este caso, para OnInitialized. Comenzaremos a hacer esto muy pronto, y sí, lo haremos en casi todos los componentes que creemos. Veremos que estos métodos se utilizan para la configuración. Interactuar con estos métodos no es muy complejo, como podemos ver aquí. Estos métodos se definen en las clases de componentes base de las que heredan nuestros componentes. Entonces, supongamos que desea agregar código a OnInitialized para realizar una inicialización adicional en nuestro componente, entonces simplemente podemos crear una anulación, en este caso, para OnInitialized. Comenzaremos a hacer esto muy pronto, y sí, lo haremos en casi todos los componentes que creemos. Veremos que estos métodos se utilizan para la configuración. Interactuar con estos métodos no es muy complejo, como podemos ver aquí. Estos métodos se definen en las clases de componentes base de las que heredan nuestros componentes. Entonces, supongamos que desea agregar código a OnInitialized para realizar una inicialización adicional en nuestro componente, entonces simplemente podemos crear una anulación, en este caso, para OnInitialized. Comenzaremos a hacer esto muy pronto, y sí, lo haremos en casi todos los componentes que creemos. en este caso, para OnInitialized. Comenzaremos a hacer esto muy pronto, y sí, lo haremos en casi todos los componentes que creemos. en este caso, para OnInitialized. Comenzaremos a hacer esto muy pronto, y sí, lo haremos en casi todos los componentes que creemos.

**Demostración: creación del componente de vista rápida**

Es hora de otra demostración. Crearemos otro componente, el componente Vista rápida. Básicamente, una ventana emergente, y la usaremos para aprender sobre los nuevos temas que acabamos de cubrir. Vamos a crear más componentes y haremos que se comuniquen entre sí. Voy a crear el componente QuickViewPopup que se puede usar para mostrar los detalles, una pequeña lista de detalles, es decir, de un empleado. Luego voy a extender mi EmployeeCard con un botón que activará el código en el padre, EmployeeOverview, y luego EmployeeOverview puede mostrar el cuadro de diálogo QuickViewPopup. Eso es lo que haremos en esta demostración. Hagámoslo paso a paso. Esto ya puede ser un poco más complejo, pero hagámoslo juntos y llegaremos allí. Volvamos primero a Visual Studio, y como se dijo, Comenzaré creando primero el componente QuickViewPopup. Ese no será un componente de relleno de página, así que lo colocaré en la carpeta Componentes. Agregaré el componente QuickViewPopup y, por supuesto, también agregaré la clase de back-end. Y lo haremos parcial, como ya sabemos a estas alturas. Este QuickViewPopup, como se dijo, mostrará los detalles, algunos de los detalles de un empleado. De nuevo, al igual que con la tarjeta de empleado, pasaré un empleado a través de un parámetro y traeré la declaración de uso para el parámetro, así como para el empleado. Ahí tienes Ahora, voy a tener que hacer un par de trucos, los cuales te explicaré en un momento, así que espera por ahora. También traeré un campo privado, _employee, un campo al lado de la propiedad, y luego lo usaré en mi interfaz de usuario. Verá por qué estoy usando tanto la propiedad _employee como el campo Empleado más adelante en esta demostración. Vayamos a la interfaz de usuario, y voy a pegar, bueno, un fragmento bastante grande de bacalao marcado. Observe lo que esto está haciendo. Esto muestra un cuadro de diálogo modal que básicamente copié del sitio web de Bootstrap. Lo puse en mi código aquí, pero lo rodeo con este bloque if aquí. Voy a mostrar esto solo si el _employee, este campo privado, no es nulo. En otras palabras, este bloque de código, por lo que todo el div, solo se mostrará cuando _employee no sea nulo. Entonces, cuando no hay ningún empleado, si _employee es nulo, entonces esto no se mostrará en absoluto. Déjame mostrarte el código aquí muy rápidamente. No hay nada realmente nuevo aquí en este punto. Simplemente tengo un código de marcado que muestra la identificación del empleado, el nombre, el apellido y la fecha de nacimiento. Esos son solo los detalles que quiero mostrar en el diálogo. Muy bien, en este punto el componente está listo. Volveremos a ello muy pronto. Ahora, necesito ir a mi EmployeeCard. En mi EmployeeCard voy a agregar esta devolución de llamada aquí, EmployeeQuickViewClicked. Eso es del tipo EventCallback. Es un evento que se desencadenará desde este componente, el componente principal, por lo que EmployeeOverview puede escuchar si este evento ocurre dentro de su elemento secundario, EmployeeCard, y reaccionar ante eso. Eso es exactamente lo que quiero. Quiero, en mi tarjeta de empleado, poder hacer clic en el botón y eso desencadenará un evento al que reaccionará mi EmployeeOverview mostrando QuickViewPopup. ¿Cuándo activará eso este evento de la tarjeta de empleado? Bueno, en la interfaz de usuario de EmployeeCard, voy a traer un botón dentro del cuerpo de la tarjeta, y ese botón, y déjame ponerlo primero en dos líneas, tiene el onclick definido, un evento, y eso activará EmployeeQuickViewClicked . Ese es este evento. Invocaré el evento, pasando el Empleado actual. Eso será solo un botón HTML simple que tiene Vista rápida como su contenido. Entonces, este tipo de evento debe ser del tipo EventCallback, y también debe tener definido el parámetro. De esta manera, desde mi padre, ahora puedo suscribirme a este evento que regresa de los componentes secundarios o de EmployeeCard. Así que ahora podemos ir a EmployeeOverview donde hemos usado EmployeeCard y podemos, aquí, decir que cuando se hizo clic en EmployeeQuickView, Quiero ejecutar código en la descripción general, así que en este componente mismo. Voy a decir que cuando EmployeeCard generó el evento EmployeeQuickViewClicked, quiero ejecutar el código ShowQuickViewPopup. Todavía no tengo eso, lo agregaré en solo un segundo, pero ese es el código en la descripción general que se enhebrará. Ahora, quiero escribir un código que básicamente se asegurará de que se muestre QuickViewPopup. Primero, en mi EmployeeOverview voy a agregar QuickViewPopup, pasando el valor para el parámetro Employee. Ese fue este parámetro aquí. De hecho, esta ventana emergente necesita que se pase un parámetro de empleado. Todavía no tengo ese _selectedEmployee, lo agregaré en solo un segundo. Pero recuerde, QuickViewPopup no se mostrará si _employee es nulo. Entonces, simplemente agregando que no veré nada aquí. Eso es de hecho lo que quiero. No quiero que esto se muestre por defecto. Solo quiero que esto se muestre cuando se hizo clic en el botón EmployeeQuickView, y luego se ejecutará este código aquí. Vayamos ahora al código de EmployeeOverview, y voy a agregar algunas cosas aquí. Traigo un campo privado y se llama _selectedEmployee. Ese es el que necesitaba pasar a mi QuickViewPopup. Y también necesito traerle un controlador de eventos, por lo que ShowQuickViewPopup. Ese es este. Y aquí voy a establecer _selectedEmployee en el pasado en selectedEmployee. Ahora déjame llevarte paso a paso una vez más. Si dentro de EmployeeCard se hizo clic en este botón, generaré el evento EmployeeQuickViewClicked. Eso es del tipo EventCallback, y pasará a un Empleado. Este es un evento en el que mi padre, EmployeeOverview, ahora está suscrito. Aquí, al definir la EmployeeCard, especifico que cuando el evento provenga de la EmployeeCard, llamaré a ShowQuickViewPopup. Ese es un evento que ingresa al empleado seleccionado de la tarjeta de empleado, y lo establecerá en la propiedad _selectedEmployee aquí. Ahora, esto realmente cambiará el valor del parámetro, del parámetro Empleado, dentro de QuickViewPopup. Así que ya casi llegamos. Cuando regrese a QuickViewPopup, usaré otro método de ciclo de vida. Hay un método que se generará automáticamente cuando se establezca o cambie un valor de un parámetro. Entonces, cuando una EmployeeCard genera un evento en EmployeeOverview, eso cambiará el valor del parámetro en QuickViewPopup, y estoy reaccionando a eso dentro de mi QuickViewPopup especificando aquí que este campo aquí debe establecerse en el valor del parámetro. Eso ya no será nulo, por lo tanto, la interfaz de usuario, este bloque completo aquí, se mostrará porque _employee ya no es nulo. Ahora necesito poder volver a establecerlo en nulo. Hay este botón aquí que descartará el cuadro de diálogo, y aquí también voy a decir, usando un evento regular, cuando se hace clic en esto, así que agregue onclick, quiero invocar el método Cerrar. Todavía no lo tenemos, pero lo agregaré en un segundo. Y, de hecho, haré exactamente lo mismo con el botón Cerrar, que está aquí abajo. Así que ahora vayamos a QuickViewPopup, y aquí necesitaremos agregar el método Cerrar, que es un método de anulación regular. Y lo que eso hará, bueno, eso simplemente hará que _employee vuelva a ser nulo. Esto volverá a activar OnParametersSet, por lo que Blazor volverá a evaluar la interfaz de usuario. Verá que _employee es nulo nuevamente, por lo tanto, todo este bloque de interfaz de usuario se ocultará nuevamente. Creo que estamos bien. A ver si todo funciona correctamente. Vamos a Empleados, vemos nuestro botón. Cuando hago clic en eso, vemos que se muestra la Vista rápida del empleado. Así que ahora mi EmployeeCard generó el evento, mi padre reaccionó estableciendo el valor _employee. Ahora puedo hacer clic en Cerrar. Eso hará que _employee vuelva a ser nulo, por lo tanto, todo QuickViewPopup se ocultará nuevamente. Así que ahora hemos visto cómo podemos hacer que varios componentes se comuniquen entre sí generando eventos, y ese evento siempre deberá ser del tipo EventCallback. Esto volverá a activar OnParametersSet, por lo que Blazor volverá a evaluar la interfaz de usuario. Verá que _employee es nulo nuevamente, por lo tanto, todo este bloque de interfaz de usuario se ocultará nuevamente. Creo que estamos bien. A ver si todo funciona correctamente. Vamos a Empleados, vemos nuestro botón. Cuando hago clic en eso, vemos que se muestra la Vista rápida del empleado. Así que ahora mi EmployeeCard generó el evento, mi padre reaccionó estableciendo el valor _employee. Ahora puedo hacer clic en Cerrar. Eso hará que _employee vuelva a ser nulo, por lo tanto, todo QuickViewPopup se ocultará nuevamente. Así que ahora hemos visto cómo podemos hacer que varios componentes se comuniquen entre sí generando eventos, y ese evento siempre deberá ser del tipo EventCallback. Esto volverá a activar OnParametersSet, por lo que Blazor volverá a evaluar la interfaz de usuario. Verá que _employee es nulo nuevamente, por lo tanto, todo este bloque de interfaz de usuario se ocultará nuevamente. Creo que estamos bien. A ver si todo funciona correctamente. Vamos a Empleados, vemos nuestro botón. Cuando hago clic en eso, vemos que se muestra la Vista rápida del empleado. Así que ahora mi EmployeeCard generó el evento, mi padre reaccionó estableciendo el valor _employee. Ahora puedo hacer clic en Cerrar. Eso hará que _employee vuelva a ser nulo, por lo tanto, todo QuickViewPopup se ocultará nuevamente. Así que ahora hemos visto cómo podemos hacer que varios componentes se comuniquen entre sí generando eventos, y ese evento siempre deberá ser del tipo EventCallback. por lo tanto, todo este bloque de interfaz de usuario se ocultará nuevamente. Creo que estamos bien. A ver si todo funciona correctamente. Vamos a Empleados, vemos nuestro botón. Cuando hago clic en eso, vemos que se muestra la Vista rápida del empleado. Así que ahora mi EmployeeCard generó el evento, mi padre reaccionó estableciendo el valor _employee. Ahora puedo hacer clic en Cerrar. Eso hará que _employee vuelva a ser nulo, por lo tanto, todo QuickViewPopup se ocultará nuevamente. Así que ahora hemos visto cómo podemos hacer que varios componentes se comuniquen entre sí generando eventos, y ese evento siempre deberá ser del tipo EventCallback. por lo tanto, todo este bloque de interfaz de usuario se ocultará nuevamente. Creo que estamos bien. A ver si todo funciona correctamente. Vamos a Empleados, vemos nuestro botón. Cuando hago clic en eso, vemos que se muestra la Vista rápida del empleado. Así que ahora mi EmployeeCard generó el evento, mi padre reaccionó estableciendo el valor _employee. Ahora puedo hacer clic en Cerrar. Eso hará que _employee vuelva a ser nulo, por lo tanto, todo QuickViewPopup se ocultará nuevamente. Así que ahora hemos visto cómo podemos hacer que varios componentes se comuniquen entre sí generando eventos, y ese evento siempre deberá ser del tipo EventCallback. Así que ahora mi EmployeeCard generó el evento, mi padre reaccionó estableciendo el valor _employee. Ahora puedo hacer clic en Cerrar. Eso hará que _employee vuelva a ser nulo, por lo tanto, todo QuickViewPopup se ocultará nuevamente. Así que ahora hemos visto cómo podemos hacer que varios componentes se comuniquen entre sí generando eventos, y ese evento siempre deberá ser del tipo EventCallback. Así que ahora mi EmployeeCard generó el evento, mi padre reaccionó estableciendo el valor _employee. Ahora puedo hacer clic en Cerrar. Eso hará que _employee vuelva a ser nulo, por lo tanto, todo QuickViewPopup se ocultará nuevamente. Así que ahora hemos visto cómo podemos hacer que varios componentes se comuniquen entre sí generando eventos, y ese evento siempre deberá ser del tipo EventCallback.


**Agregar navegación**

Nuestra aplicación ya contiene algunos componentes y tenemos algunas páginas, pero ¿cómo podemos agregar una navegación real entre las diferentes páginas y cómo podemos pasar datos de una página a la siguiente? Averigüémoslo en esta parte. El enrutamiento está, digamos, habilitado en la aplicación Blazor a través de otro componente que obtenemos del marco, a saber, el enrutador. Esto se crea de forma predeterminada en el archivo App.razor, que fue generado por la plantilla. Cuando navegamos, es el enrutador el que nos indicará la página correcta. Ahora, ¿cómo hace eso? Bueno, ya hemos visto que los llamados componentes de página tienen una directiva de página en la parte superior, con el valor del nombre de la ruta que podemos usar para llegar a ellos. En la compilación, cuando un componente tiene una directiva de página, esto se traducirá en un atributo de ruta que se agregará en la clase generada. Cuando ahora ejecutamos la aplicación, se escanea el ensamblaje en busca de todos los componentes con este atributo y, básicamente, se crea una lista de todas las rutas conocidas. Cuando ahora queremos navegar, es el enrutador el que buscará en esta lista y verá a qué componente debemos enrutar. Al navegar, hasta ahora solo hemos usado la directiva de página sin ningún parámetro adicional. Sin embargo, es posible pasar uno o más parámetros al enrutar, para que estos valores estén disponibles en el componente al que estamos enrutando. Podemos navegar usando enlaces, como lo hemos hecho hasta ahora, pero también es posible activar la navegación desde el código. Una clase integrada viene con Blazor que podemos usar para este mismo propósito, a saber, NavigationManager. Tendremos que usar la inyección de dependencia para inyectar esto en los lugares desde donde queremos usarlo, y lo veremos pronto. Una cosa, ya hemos tocado la inyección de dependencia unas cuantas veces, lo veremos con más detalle pronto. No se preocupe si este concepto aún no está del todo claro. Comencemos mirando el enrutador, el componente responsable de enrutarnos al componente correcto de Razor. Como ya se explicó, el ensamblaje de la aplicación se analiza en busca de todas las rutas disponibles al observar todas las clases de componentes que tienen definido el atributo de ruta. Cuando se ejecuta la aplicación y se encuentra la ruta solicitada, la parte Encontrada aquí realmente se ejecutará. En este caso, RouteView recibirá los datos de ruta del navegador, junto con cualquier parámetro. Esto dará como resultado que se represente el componente solicitado, junto con su diseño. Y si el componente no define un diseño en sí mismo, se utiliza el valor predeterminado especificado aquí. Esto es lo que hemos hecho hasta ahora, se utilizó nuestro diseño predeterminado. Si no se encuentra la ruta solicitada, pues entonces se mostrará la h1 con el mensaje que vemos aquí. Para hacer que un componente sea enrutable, lo que significa que podemos enrutarlo, como se dijo, debemos incluir una directiva de página en la parte superior. Esto da como resultado un componente al que podemos navegar. Por lo tanto, se puede acceder a este componente navegando a /employeeoverview. Es posible agregar varias directivas de página en un solo componente. El resultado neto es que ahora se puede acceder a este componente navegando a /employeeoverview y /employeelist. Una cosa más, las rutas deben ser únicas en la aplicación. No es posible que podamos llegar a múltiples componentes con la misma ruta. Las rutas que acabamos de ver y usar hasta ahora, de hecho, no permitían una parte dinámica en el camino. Es posible, sin embargo, incluir un parámetro en la ruta, y eso lo podemos ver aquí. En la ruta en sí, ahora he incluido un segmento adicional donde vemos que EmployeeId ahora está entre llaves. EmployeeId es un parámetro de ruta y su valor estará disponible en el código del componente en una propiedad regular llamada EmployeeId, marcada de nuevo con el atributo Parámetro. De hecho, ese es el mismo atributo que ya usamos para los parámetros entre los componentes padre e hijo. Curiosamente, el parámetro no distingue entre mayúsculas y minúsculas. También podemos restringir el parámetro de ruta. Echa un vistazo al código aquí en la diapositiva. Ahora tengo un parámetro Id en el segmento de ruta y luego :int. En otras palabras, esta ruta ahora solo será una coincidencia si el valor pasado es de tipo entero. En la clase de componente, la propiedad Id que está marcada con el atributo Parámetro ahora también es de tipo int. Es posible pasar valores de parámetros también a través de la cadena de consulta. Para que Blazor básicamente busque en la cadena de consulta el valor de un parámetro, junto al atributo Parámetro, debemos decorar la propiedad también con el atributo SupplyParameterFromQuery, pasando el nombre del parámetro de cadena de consulta que queremos usar. De hecho, este último solo es necesario si el nombre del parámetro en la cadena de consulta es diferente del nombre de la propiedad, como tenemos aquí. Una cosa más sobre el enrutamiento antes de regresar a la demostración, el NavigationManager, que ya mencioné brevemente. Podemos realizar la navegación creando enlaces en el código Razor, como ya hemos visto, pero también tendremos la necesidad de trabajar programáticamente con la ruta. Podemos realizar la navegación creando enlaces en el código Razor, como hemos visto ahora. Pero cuando tenemos la necesidad de trabajar programáticamente con la ruta, necesitamos usar el NavigationManager. Quizás queremos que la navegación sea condicional. Bueno, ese tipo de cosas que no podemos hacer en el código Razor. El NavigationManager es un tipo integrado en Blazor y, de hecho, se agrega al contenedor de inserción de dependencias para nosotros. Por lo tanto, podemos usarlo sin necesidad de ningún registro. Nuevamente, si todo el concepto sobre la inyección de dependencia no está claro, no se preocupe, llegaremos a eso. Entonces, cuando queramos trabajar con rutas desde el código, necesitaremos inyectar el NavigationManager, y eso es lo que vemos que sucede aquí. Tengo una propiedad NavigationManager atribuida con el atributo Inyectar. Eso nos dará acceso en el código a una instancia de esta clase. Luego podemos usarlo para navegar programáticamente. El método más utilizado en NavigationManager es NavigateTo, al que luego pasamos la ruta que queremos navegar.

**Demostración: Navegación al componente Detalles**

Es hora de volver a Visual Studio y traer otro componente. Agregaremos esta vez el componente EmployeeDetails y usaremos lo que hemos aprendido en esta parte para poder navegar a este nuevo componente. También necesitaremos un parámetro, para que el componente de detalles sepa qué empleado mostrar. Presenté este componente Vista rápida para brindar una descripción general rápida de algunos de los detalles del empleado, pero también quiero navegar a la página de detalles completos. Entonces, lo que haremos es crear otro componente, el componente EmployeeDetail, pero ahora no trabajaremos con componentes anidados; introduciremos la navegación y pasaremos datos a través de la URL a esta segunda página, y esa también será una forma de parámetros que usaremos para capturar esos datos en ese detalle de empleado. Así que veamos cómo vamos a hacer eso en esta demostración. Primero, voy a presentar otro componente nuevo que será el detalle del empleado. Ahora, este será otro componente de relleno de página, así que lo agrego en Páginas. Es un componente al que navegaré. Entonces agregaremos un atributo de página en solo un segundo. Primero, agregue nuestro componente EmployeeDetail y también agregue la ID de clase de respaldo. Creo que ya conoces el ejercicio. Como se dijo, tendremos que poder navegar a esta página. Ya vimos cómo podíamos navegar a la Descripción general del empleado agregando una directiva @page. Ahora, tendré que introducir también un parámetro aquí. Así que ahora voy a decir que se puede llegar a esta página navegando a employeeDetail, pasando también un segundo segmento, y ese es EmployeeId. Ese será el EmployeeId del que queremos mostrar los detalles. Y necesitaremos acceso al valor de EmployeeId dentro de la clase Component. Así que dentro de la clase EmployeeDetail, voy a introducir de nuevo un parámetro de tipo cadena y será EmployeeId. Y para indicar que este valor, de hecho, debe recuperarse de este EmployeeId, volveré a utilizar el atributo Parámetro. Entonces podemos decir que este atributo de Parámetro está de alguna manera sobrecargado. Podemos usarlo para capturar datos pasados ​​desde el back-end, pero también puede usarlo para capturar datos pasados ​​desde la cadena de consulta. Tendremos que recuperar al empleado, el empleado completo de alguna parte. Esa será una propiedad que se llenará y que también usará para vincular la interfaz de usuario. Entonces, lo que haré es crear una nueva propiedad de tipo Empleado aquí, y que usaremos para mostrar los detalles de este empleado. Ahora, ¿cómo vamos a encontrar a ese empleado? Bueno, vamos a recuperarlo del servicio de datos, nuevamente. En este punto, seguirá siendo MockDataService. Así que voy a volver a hacer una anulación, y ahora voy a usar el asíncrono no inicializado. Voy a obtener de MockDataService el valor del empleado con el EmployeeId que se está transfiriendo. Así que pegué un código aquí que volverá a nuestra propiedad MockDataService.Employees, y obtengo el primer empleado donde el EmployeeId es igual al valor analizado de EmployeeId, por lo que este parámetro aquí. Ya estoy usando la versión asíncrona aquí porque más adelante, la reemplazaremos con un código que va a una API, y no necesito ser asíncrono en ningún caso. Ahora que tenemos acceso al EmployeeId pasado, recuperamos al empleado en OnInitializedAsync. Ahora tenemos ese empleado y podemos usarlo para mostrar los detalles de ese empleado en la interfaz de usuario y, de hecho, no habrá muchas cosas nuevas aquí. Permítanme pegar la interfaz de usuario de nuestro componente y lo llevaré rápidamente. Dado que hay mucho código, hay, por supuesto, un fragmento, por lo que lo encontrará con las descargas de este módulo. La mayor parte de esto es solo código de maqueta que dije. así que voy a mostrar los detalles de Employee.FirstName, .LastName. Vuelvo a mostrar una imagen y luego muestro EmployeeId, FirstName, LastName, BirthDate. También puedo usar, por ejemplo, un método como ToShortDateString para formatear la fecha correctamente. Muestro el correo electrónico, la calle, el código postal, la ciudad, el número de teléfono, el género. Utilizo un pequeño bloque de código aquí para verificar si el empleado es fumador, sí o no. Luego tenemos JoinedDate?.ToShortDateString, ExitDate?.ToShortString, y creo que eso es todo. Aquí vamos. Así que realmente no hay nada nuevo que aprender aquí. Esto solo muestra los detalles del empleado punteando sus propiedades. Ahora quiero volver a mis tarjetas de empleado, y allí agregaré un nuevo botón que me permita navegar a esta página de detalles. De hecho, voy a usar una etiqueta de anclaje simple, por lo que un enlace que tiene un href, pasando el Employee.EmployeeId de la tarjeta. La tarjeta tenía la propiedad Employee y pasó en EmployeeId, ya que este enlace contiene todos los detalles. Probemos eso. Así que ahora tendremos navegación real. Cuando voy a Empleados, el botón Detalles completos aquí, y eso irá a employeedetail/1. Esa URL corresponde de hecho con /employeedetail/EmployeeId. Ese valor de ese EmployeeId llegará aquí en la propiedad EmployeeId, que se atribuye con el atributo de parámetro, y que luego se usa en OnInitializedAsync para recuperar los datos de, en este caso, MockDataService. Así que ahora tenemos navegación real, tenemos navegación entre el maestro, una descripción general y una página de detalles. Y esto es, de hecho, solo usando un enlace simple, y no tenemos ninguna influencia en el código sobre cómo se llevará a cabo la navegación. De hecho, también podemos activar la navegación desde el código, es decir, desde la clase Component. Permítanme volver a la Tarjeta de empleado y, en lugar de tener solo un enlace, voy a incluir aquí un botón en el que luego puedo hacer clic. Así que ahora reemplacé esta etiqueta de anclaje con un botón que tiene un clic que especifica aquí que voy a navegar a los detalles, pasando el Empleado nuevamente. Ahora, hacer la navegación desde el código, de hecho, requiere que use el Administrador de navegación. Ese es un _____ que viene con Blazor y debemos inyectarlo en el componente mediante el atributo Inyectar. Eso es lo que vemos aquí. Entonces, el Administrador de navegación viene con Blazor, creo una propiedad de ese tipo y necesito atribuirla con Inyectar. Ahora bien, esto tiene que ver con la inyección de dependencia. De hecho, voy a inyectar una instancia del Administrador de navegación directamente en este componente. No tenemos que hacer nada más. Es un tipo conocido para Blazor, pero solo necesitamos especificar aquí en el componente que queremos inyectar esto en la colección de inyección de dependencia. Hablaremos más sobre la inyección de dependencia muy pronto. Había escrito en la interfaz de usuario el método al hacer clic y usé la sintaxis lambda aquí para decir NavigateToDetails, pasando el empleado. Si navego por los detalles, aún tendré que crear, eso es lo que ves aquí. Y ahora tenemos un método, NavigateToDetails, que ingresa al empleado seleccionado, y uso NavigationManager.Navigate2, y ahora navego a través del código hasta employeedetail/EmployeeId. Así que ahora podemos escribir código para tener control sobre cómo funcionará la navegación. Podríamos, por ejemplo, verificar la condición primero y luego navegar solo si esa condición se cumple. A ver si todo sigue funcionando bien. Volvamos a nuestra página de Empleados, Detalles completos, y el comportamiento es exactamente el mismo, pero ahora navegamos a través del Administrador de navegación.


**Usando RenderFragmento**

Conozcamos otro aspecto interesante sobre los componentes, la configuración de contenidos mediante el uso de RenderFragment. Digamos que hemos creado un componente llamado ProfilePicture. Es, por cierto, un componente que pronto crearemos en una demostración. Al usar este componente, así desde otro componente, hemos visto que podemos pasarle información mediante el uso de uno o más parámetros. También podemos decir, pasarle datos, colocando datos entre las etiquetas de apertura y cierre del componente. En otras palabras, estamos configurando el contenido. Ese contenido pasa a estar disponible para el componente, por lo que el componente ProfilePicture, y luego puede usarlo. De hecho, esto se parece bastante al uso de parámetros que ya hemos visto, pero es algo especial. Un componente, representado por una etiqueta de apertura y cierre, solo puede usar una pieza de contenido. Al usarlo, el contenido se insertará automáticamente, digamos, en una propiedad en el componente de tipo RenderFragment, como podemos ver aquí. Más específicamente, la propiedad debe llamarse ChildContent. Por lo tanto, la propiedad debe llamarse ChildContent y el tipo debe ser RenderFragment y, de hecho, la propiedad debe tener un atributo de parámetro adjunto. Dentro del componente, ahora podemos usar el componente secundario como cualquier otra propiedad, y eso básicamente dará como resultado que el contenido se muestre en esta ubicación. Como se dijo, para que esto funcione, la propiedad debe llamarse ChildContent. Si le das cualquier otro nombre, el cableado automático no funcionará. la propiedad debe llamarse ChildContent. Por lo tanto, la propiedad debe llamarse ChildContent y el tipo debe ser RenderFragment y, de hecho, la propiedad debe tener un atributo de parámetro adjunto. Dentro del componente, ahora podemos usar el componente secundario como cualquier otra propiedad, y eso básicamente dará como resultado que el contenido se muestre en esta ubicación. Como se dijo, para que esto funcione, la propiedad debe llamarse ChildContent. Si le das cualquier otro nombre, el cableado automático no funcionará. la propiedad debe llamarse ChildContent. Por lo tanto, la propiedad debe llamarse ChildContent y el tipo debe ser RenderFragment y, de hecho, la propiedad debe tener un atributo de parámetro adjunto. Dentro del componente, ahora podemos usar el componente secundario como cualquier otra propiedad, y eso básicamente dará como resultado que el contenido se muestre en esta ubicación. Como se dijo, para que esto funcione, la propiedad debe llamarse ChildContent. Si le das cualquier otro nombre, el cableado automático no funcionará. y eso básicamente dará como resultado que el contenido se muestre en esta ubicación. Como se dijo, para que esto funcione, la propiedad debe llamarse ChildContent. Si le das cualquier otro nombre, el cableado automático no funcionará. y eso básicamente dará como resultado que el contenido se muestre en esta ubicación. Como se dijo, para que esto funcione, la propiedad debe llamarse ChildContent. Si le das cualquier otro nombre, el cableado automático no funcionará.

**Demostración: uso de RenderFragment**

Bastante simple, ¿no? Volvamos a Visual Studio y usemos la propiedad ChildContent para pasar contenido. Ahora voy a crear un componente que se mostrará justo aquí y que contendrá la imagen, la imagen de perfil, digamos, de Bethany. Y podríamos hacer eso con una imagen regular, pero voy a crear un nuevo componente para eso, el componente ProfilePicture. Y en lugar de pasar datos a través de un parámetro, usaré ChildContent. Voy a permitir pasar datos entre las etiquetas abiertas y cerradas al componente, y eso luego se usará dentro del componente. Probemos eso. Nuestro componente ProfilePicture que voy a crear, por supuesto, no será un componente de relleno de página, así que creo un nuevo componente en la carpeta Componentes y lo llamaré ProfilePicture. Y como siempre, crearemos una clase de respaldo. Ahora, como dije, lo que voy a hacer es cuando use este componente ProfilePicture en otro lugar de mi aplicación, quiero poder pasar solo entre las etiquetas abiertas y cerradas para pasar datos para pasar un valor. Ese valor lo podemos capturar dentro de este componente ProfilePicture usando, nuevamente, un parámetro, pero ese parámetro será de un tipo específico, de tipo RenderFragment, y debe llamarse ChildContent, y eso es lo que vemos aquí. Entonces, cuando nombramos una propiedad ChildContent, el contenido, por lo que el marcado pasado entre las etiquetas abiertas y cerradas cuando se usa este componente, se conectará a esta propiedad ChildComponent. Entonces, cuando uso este componente ProfilePicture, el contenido pasado entre las etiquetas abiertas y cerradas llegará a este ChildContent. Una propiedad ChildContent es de tipo RenderFragment, y RenderFragment es un tipo integrado que representa un segmento del contenido de la interfaz de usuario. En otras palabras, normalmente pasaré un poco de contenido HTML a esta propiedad ChildContent, y eso se representará dentro del HTML. Y ahora puedo usar ese ChildContent de manera regular dentro de la interfaz de usuario de mi componente ProfilePicture. Y usemos un div regular con una imagen de perfil de clase, y luego uso @ChildContent. Simplemente muestro el valor, que será un segmento de la interfaz de usuario dentro de este div. No creo que ya tenga la clase ProfilePicture en mi CSS, así que lo haré ahora. Iré a wwwroot, css, app.css, y hasta el final, traeré esta clase de imagen de perfil que agrega una opacidad de 0.7 al div y, por lo tanto, también al ChildContent. Genial, ahora tengo mi componente ProfilePicture. No se necesita nada más. Ahora puedo usar esto, y lo voy a usar, creo, desde mi NavMenu. Ahora, antes de usarlo, primero hagamos una compilación. Y ahora puedo usar esto como un componente normal, ProfilePicture, pero ahora solo puedo pasar datos entre las etiquetas de apertura y cierre. Ese será el código de marcado, un segmento de la interfaz de usuario, y luego se representará cuando se use el parámetro ChildContent. Entonces, si coloco la imagen, en este caso, que quiero usar, es el profilePicture.jpg dentro de la carpeta de imágenes, que luego se conectará a esta propiedad ChildContent. Es un RenderFragment. Necesita un poco de interfaz de usuario. Y eso se mostrará aquí donde se usa ChildContent. Eso es, por supuesto, solo el parámetro ChildContent que estoy usando aquí. Pero es importante que este parámetro se llame ChildContent; de lo contrario, esto no funcionará. A ver si lo he hecho todo bien. Así que ahí vamos. Ahora vemos que se muestra la imagen de perfil y también se le aplica la opacidad.

**Cargando Componentes Dinámicamente**

Hasta ahora, siempre hemos agregado los componentes que queríamos visualizar en otro componente de forma declarativa. También es posible cargar componentes dinámicamente, lo que abre algunos escenarios más dinámicos. Déjame mostrarte cómo podemos usar esta función. Imagine que estamos creando la página de inicio de Bethany's Pie Shop HRM, y queremos que sea como un tablero para que nuestros usuarios obtengan información útil de un vistazo. Puede ver una maqueta, donde en el área principal de la página de inicio, muestro cuántos mensajes tiene el usuario, cuántos empleados hay actualmente en el sistema, así como el clima. Por supuesto, podemos agregar todos estos componentes de forma declarativa, usando HTML, pero también podemos dejar que los componentes se agreguen dinámicamente. Incluso podemos cargar los componentes de forma condicional, por lo que tal vez queramos cargar ciertos componentes solo para ciertos usuarios. Con una página estática, hacer esto puede llevar algún tiempo. Blazor viene con DynamicComponent, que admite la representación de un componente por tipo. Suena un poco confuso, ¿no? Lo entiendo, déjame explicarte. Aquí en la diapositiva, puede ver que he declarado un componente dinámico, como un componente normal que creamos nosotros mismos. Eso define un parámetro de tipo, y ese tipo se puede establecer en un tipo que establecemos en el código, incluso de forma dinámica. Incluso podemos pasar parámetros adicionales si el tipo pasado lo requiere. Si hacemos esto, por ejemplo en un ciclo, podemos hacer lo que les mostré anteriormente, podemos recorrer una matriz de tipos e instanciar dinámicamente mediante el uso de componentes DynamicComponent. ¿no es así? Lo entiendo, déjame explicarte. Aquí en la diapositiva, puede ver que he declarado un componente dinámico, como un componente normal que creamos nosotros mismos. Eso define un parámetro de tipo, y ese tipo se puede establecer en un tipo que establecemos en el código, incluso de forma dinámica. Incluso podemos pasar parámetros adicionales si el tipo pasado lo requiere. Si hacemos esto, por ejemplo en un ciclo, podemos hacer lo que les mostré anteriormente, podemos recorrer una matriz de tipos e instanciar dinámicamente mediante el uso de componentes DynamicComponent. ¿no es así? Lo entiendo, déjame explicarte. Aquí en la diapositiva, puede ver que he declarado un componente dinámico, como un componente normal que creamos nosotros mismos. Eso define un parámetro de tipo, y ese tipo se puede establecer en un tipo que establecemos en el código, incluso de forma dinámica. Incluso podemos pasar parámetros adicionales si el tipo pasado lo requiere. Si hacemos esto, por ejemplo en un ciclo, podemos hacer lo que les mostré anteriormente, podemos recorrer una matriz de tipos e instanciar dinámicamente mediante el uso de componentes DynamicComponent. Incluso podemos pasar parámetros adicionales si el tipo pasado lo requiere. Si hacemos esto, por ejemplo en un ciclo, podemos hacer lo que les mostré anteriormente, podemos recorrer una matriz de tipos e instanciar dinámicamente mediante el uso de componentes DynamicComponent. Incluso podemos pasar parámetros adicionales si el tipo pasado lo requiere. Si hacemos esto, por ejemplo en un ciclo, podemos hacer lo que les mostré anteriormente, podemos recorrer una matriz de tipos e instanciar dinámicamente mediante el uso de componentes DynamicComponent.

**Demostración: carga de widgets en la pantalla de inicio**

Esto realmente necesitamos verlo en acción, así que es hora de regresar a Visual Studio y cargar algunos widgets en la página de inicio, bueno, dinámicamente. Este es el estado actual del índice de la página de destino de la página de inicio. De hecho, también quiero mejorar eso con algo de contenido dinámico. Volveré a crear un par de componentes y puedo colocarlos directamente dentro del siguiente componente, pero ahora usaremos el componente dinámico. Dejaremos que Blazor represente dinámicamente un conjunto de componentes mediante el componente dinámico. Vamos a probarlo. En la carpeta Activos de este módulo, M4, encontrará una carpeta llamada Widgets. Copie esa carpeta en la carpeta Componentes dentro de Visual Studio. Allí encontrarás, en este caso, solo dos widgets. Son solo componentes simples. Tenemos el componente EmployeeCountWidget, que muestra cuántos empleados tenemos actualmente en Bethany's Pie Shop. Eso devolverá el recuento de empleados de nuestro MockDataService. El InboxWidget es otro componente que verificará el conteo de mensajes, y si ese valor es mayor a 0, entonces mostrará este mensaje, de lo contrario mostrará que no tenemos preguntas. El valor de MessageCount es un valor aleatorio que se crea aquí. Ahora podría agregar directamente tanto el componente InboxWidget como el componente EmployeeCountWidget en mi componente Index, pero en su lugar, lo que haré es crear una lista de componentes y representarla usando el componente dinámico. Entonces, vayamos a nuestro índice y, de hecho, necesitaré agregar una clase de componente de índice porque también necesitaré agregar algo de código allí. Lo que creo aquí es que crearé una lista de tipos llamados Widgets, y esa lista de tipos contiene los tipos de EmployeeCountWidget y el tipo de InboxWidget. Esos son componentes. Solo traeré la declaración de uso correcta. Entonces, en otras palabras, ahora he creado una lista de tipos, tipos de componentes que querré renderizar dinámicamente. Ahora, la lista de widgets todavía está codificada, pero, por supuesto, llenar esa lista puede ser algo dinámico. Podemos ir a una base de datos para comprobar si se debe mostrar un determinado tipo de widget. También podemos consultar otras condiciones. Entonces, esta lista ahora está codificada, pero puede ser algo dinámico. Ahora, puedo ir a mi interfaz de usuario del índice y actualizaré el código para eso. Aquí, voy a recorrer la colección de widgets. La colección de widgets era una lista de tipos. Así que voy a, para cada tipo, crear ahora un DynamicComponent, y voy a especificar que el tipo debe ser widgetType. Esto dará como resultado que Blazor represente ese tipo dinámicamente. Vamos a probarlo. Y ahí vamos. Ahora tenemos nuestro Contador de empleados y nuestra Bandeja de entrada aquí en la página de inicio, en la página de índice, eso es. Con lo que podemos jugar es, por supuesto, con esa lista de widgets. Como dije, podemos agregar condiciones, agregar o eliminar ciertos tipos de esa colección, y eso puede resultar en la creación de una página de inicio dinámica.

**Manejo de errores en componentes**

Cuando falla un componente de Blazor, normalmente se muestra un error predeterminado. Mientras eso funciona, puede que no sea el mejor enfoque para una aplicación de producción creada con Blazor. Podemos hacerlo mejor. Veamos cómo. Este es el manejo de errores predeterminado que obtenemos cuando un componente falla en nuestra aplicación. Podemos ver una barra en la parte inferior de la pantalla, y si abre las herramientas del navegador, allí también verá más detalles sobre la excepción, lo que con suerte le dará una pista de lo que realmente sucedió. Esto es lo que sucede en detalle. Digamos que hemos creado un componente para mostrar un empleado individual, aquí se representa con el nombre y el apellido. Pero nuestro código de alguna manera espera que ambos valores de cadena estén allí, y parece que para el tercer registro aquí, falta el apellido. Esto provoca una excepción no controlada en el componente, que de hecho se expandirá hasta el nivel de la aplicación y, a continuación, se muestra esta forma predeterminada de gestionar el error. De forma predeterminada, las excepciones no controladas que sucedan en cualquier componente que usemos se controlarán de esta manera. Definitivamente podemos mejorar esto usando otra característica de Blazor llamada límites de error. Como su nombre lo indica, al usar límites de error, podemos crear un límite alrededor del error y manejarlo localmente en lugar de dejar que crezca. Digamos que nuevamente el componente aquí en la tercera fila causa la misma excepción no controlada. Cuando envolvemos nuestro componente dentro de un límite de error, el componente puede mostrar una interfaz de usuario de error si algo sale mal, y mostrará la interfaz de usuario predeterminada si no ocurre ninguna excepción. Podemos envolver casi todos los componentes dentro de un límite de error, que es lo que ves aquí. Estoy usando nuestra EmployeeCard nuevamente, y esto podría estar nuevamente dentro de un bucle. El componente sigue funcionando, como antes, pero si algo sale mal dentro del componente, en este caso, se mostrará una interfaz de usuario de error predeterminada en el nivel del componente. Es posible que la interfaz de usuario de error predeterminada, que indica que se ha producido un error, no sea exactamente lo que está buscando. Podemos definir lo que queremos mostrar si ocurre una excepción no controlada, especificando el contenido del error, como podemos ver aquí. El componente que queremos envolver ahora está envuelto dentro de ChildContent. Es posible que la interfaz de usuario de error predeterminada, que indica que se ha producido un error, no sea exactamente lo que está buscando. Podemos definir lo que queremos mostrar si ocurre una excepción no controlada, especificando el contenido del error, como podemos ver aquí. El componente que queremos envolver ahora está envuelto dentro de ChildContent. Es posible que la interfaz de usuario de error predeterminada, que indica que se ha producido un error, no sea exactamente lo que está buscando. Podemos definir lo que queremos mostrar si ocurre una excepción no controlada, especificando el contenido del error, como podemos ver aquí. El componente que queremos envolver ahora está envuelto dentro de ChildContent.

**Demostración: uso del límite de error**

Volvamos a Visual Studio y agreguemos un límite de error en nuestra aplicación. Nuestra EmployeeCard mostrará los detalles de nuestro empleado dentro de la descripción general. Voy a agregar un código aquí que, de hecho, generará una excepción, cuando, en este caso, el apellido estaría vacío. Simplemente voy a ir a OnInitialized nuevamente, y si el apellido del empleado es nulo o está vacío, voy a lanzar una nueva excepción. Ahora, en este punto, solo tenemos dos empleados sentados en ese servicio de datos simulado, voy a agregar un tercero que en realidad tendrá una cadena vacía para su apellido. Así que vayamos a nuestro MockDataService, y donde teníamos estos dos empleados, voy a agregar un tercero, que efectivamente, de hecho, no tiene apellido, es una cadena vacía. Lo he añadido aquí a la lista de empleados. Si ahora ejecutamos nuestra aplicación, obtendremos un error. Entonces, si ahora navego a Empleados, vemos esa barra amarilla en la parte inferior, que de hecho dice que ocurrió un error. El error ocurrió en un componente secundario, EmployeeCard, pero se expandió hasta el nivel de la página. Si echamos un vistazo a las herramientas del navegador en la consola, veremos que un componente lanzó una excepción no controlada que dice que el apellido no puede estar vacío. Por lo tanto, su aplicación no fallará, pero aún así no es una buena manera de manejar el error dentro del componente. Entonces, lo que haré es envolver mi componente EmployeeCard para que los errores que se arrojen dentro de EmployeeCard no se borboteen hasta la página, sino que se manejen, bueno, dentro del componente. Así que iré a EmployeeOverview nuevamente, y aquí usamos directamente la EmployeeCard, que ahora estaba causando la excepción. Entonces, en lugar de usar eso directamente, lo envolveré dentro de un ErrorBoundary. Luego especifico que ChildContent sigue siendo la tarjeta de empleado original al tener ese empleado y ese EmployeeQuickViewClicked, por lo que cualquier error que se arroje ahora se detiene, digamos, en este ErrorBoundary. También especifico ErrorContent aquí, que simplemente dirá Empleado no válido. Podría mostrar alguna otra interfaz de usuario, pero este ErrorContent se mostrará si se lanza una excepción en EmployeeCard. Y ya no obtendremos esa barra amarilla, en su lugar veremos este ErrorContent. Probemos eso. Volvamos a Empleados y, como vemos, se muestra Empleado no válido y no se muestra ninguna barra amarilla en la parte inferior. ErrorBoundary impidió que el error se propagara hasta el nivel de la página. Y si revisamos la consola, todavía se lanza una excepción, eso es bastante normal, pero la interfaz de usuario no está bloqueada por ella.

**Uso de componentes incorporados**

En la parte final de este módulo, quiero hablar un poco más sobre los componentes integrados, es decir, los componentes que vienen gratis con el marco Blazor. Ya lo he enfatizado, quizás demasiadas veces, pero en Blazor, todo es un componente. Los componentes son realmente el bloque de creación más importante de cualquier aplicación Blazor y, hasta ahora, ya hemos cubierto mucho sobre ellos y cómo crearlos. Dado que todo es un componente, muchos de los componentes básicos de cualquier aplicación Blazor también son componentes. Ya hemos mencionado bastantes conceptos que, de hecho, también son componentes. Puede que no te hayas dado cuenta de esto. App.razor es un componente y contiene el enrutador, y ese también es un componente. Ha visto en este módulo DynamicComponent y ErrorBoundary. No será una sorpresa que estos también sean componentes. Pero también NavMenu y NavLink son componentes integrados. El NavLink es un componente que se usa en la aplicación generada por defecto cuando ejecutamos Archivo Nuevo Proyecto. Se comporta de manera muy similar a una etiqueta de anclaje regular, es decir, una etiqueta de enlace, pero también agrega la capacidad de cambiar una clase CSS activa, si la página actual coincide con su valor para el href. El NavMenu también lo podemos encontrar en un proyecto recién generado. La mayoría de estos componentes ya los hemos visto o usado, pero para otros grupos de funciones, Blazor viene con, bueno, más componentes, y agregaremos soporte para autenticación y autorización en la aplicación más adelante en el curso. Allí también, Blazor viene con una serie de componentes con algunas funciones útiles. Uno de estos es AuthorizeView, que se puede utilizar para ocultar o mostrar contenidos en función de si el usuario está conectado o no y si forma parte de un rol determinado. Además, al crear formularios, lo que haremos pronto, nos basaremos en muchos de los componentes de construcción. Blazor viene con un conjunto completo de componentes de entrada, que envolverán los componentes de entrada HTML predeterminados. Y ahora, finalmente, hay un conjunto de componentes misceláneos que nos brindan, bueno, alguna funcionalidad adicional. Uno de ellos es el PageTitle. El componente PageTitle permitirá, desde código Blazor, establecer el título de la página que aparecerá en el navegador. que envolverá los componentes de entrada HTML predeterminados. Y ahora, finalmente, hay un conjunto de componentes misceláneos que nos brindan, bueno, alguna funcionalidad adicional. Uno de ellos es el PageTitle. El componente PageTitle permitirá, desde código Blazor, establecer el título de la página que aparecerá en el navegador. que envolverá los componentes de entrada HTML predeterminados. Y ahora, finalmente, hay un conjunto de componentes misceláneos que nos brindan, bueno, alguna funcionalidad adicional. Uno de ellos es el PageTitle. El componente PageTitle permitirá, desde código Blazor, establecer el título de la página que aparecerá en el navegador.

**Demostración: uso del componente PageTitle**

En la demostración final de este módulo, vamos a trabajar con este componente de título de página. Aquí está de nuevo nuestra descripción general del empleado y, como podemos ver en el navegador, en realidad no se muestra ningún título. De hecho, puedo usar un componente incorporado para mostrar el título. El título puede, de hecho, ser dinámico. No voy a hacerlo dinámico en este caso, pero en realidad puede ser una cadena dinámica. Entonces, en el código de Resumen de empleados, agrego aquí un título de cadena, Resumen de empleados, y dije, por supuesto, puede ser dinámico; podemos cambiar eso desde el código. Ahora puedo ir a mi Resumen de empleados y puedo usar un componente integrado, que es, en este caso, el título de la página. Es un componente integrado que viene con Blazor entre sus etiquetas de apertura y cierre. Entonces podemos decir aquí que queremos mostrar el valor del título. Eso es esa cadena que creamos aquí. Si volvemos a ejecutar la aplicación, veremos que el título de la página Resumen de empleados ahora es Resumen de empleados. Si navegamos a Empleados, veremos que ahora desde el código, hemos cambiado el título.

**Resumen**

Ahí vamos, ahora somos maestros de componentes en Blazor. Hemos cubierto mucho terreno en torno a los componentes y vamos a resumir algunos de los conceptos clave que hemos visto en este módulo. Hemos visto que podemos mostrar datos y manejar eventos dentro de los componentes. Hemos analizado bastantes opciones en torno a los parámetros, que permiten que los componentes se comuniquen o pasen datos. Los parámetros también se usaron cuando analizamos la navegación. Es posible navegar a un componente si está decorado con la directiva @page. El componente que maneja todo lo relacionado con el enrutamiento es el enrutador. También analizamos los componentes representados dinámicamente, así como los límites de error, que nos permiten mantener las excepciones no controladas dentro de los límites del componente. Finalmente analizamos con más profundidad los componentes integrados, y que haremos mucho más en los próximos módulos. Pasemos al siguiente módulo, donde ahora reemplazaremos nuestros datos codificados con datos reales, provenientes de una API.
